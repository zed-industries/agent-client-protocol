package emit

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"sort"
	"strings"

	"github.com/zed-industries/agent-client-protocol/go/cmd/generate/internal/ir"
	"github.com/zed-industries/agent-client-protocol/go/cmd/generate/internal/load"
	"github.com/zed-industries/agent-client-protocol/go/cmd/generate/internal/util"
)

// WriteTypesJen emits go/types_gen.go with all types and the Agent/Client interfaces.
func WriteTypesJen(outDir string, schema *load.Schema, meta *load.Meta) error {
	f := NewFile("acp")
	f.HeaderComment("Code generated by acp-go-generator; DO NOT EDIT.")

	// Deterministic order
	keys := make([]string, 0, len(schema.Defs))
	for k := range schema.Defs {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, name := range keys {
		def := schema.Defs[name]
		if def == nil {
			continue
		}

		if def.Description != "" {
			f.Comment(util.SanitizeComment(def.Description))
		}

		switch {
		case len(def.Enum) > 0:
			f.Type().Id(name).String()
			defs := []Code{}
			for _, v := range def.Enum {
				s := fmt.Sprint(v)
				defs = append(defs, Id(util.ToEnumConst(name, s)).Id(name).Op("=").Lit(s))
			}
			if len(defs) > 0 {
				f.Const().Defs(defs...)
			}
			f.Line()
		case isStringConstUnion(def):
			f.Type().Id(name).String()
			defs := []Code{}
			for _, v := range def.OneOf {
				if v != nil && v.Const != nil {
					s := fmt.Sprint(v.Const)
					defs = append(defs, Id(util.ToEnumConst(name, s)).Id(name).Op("=").Lit(s))
				}
			}
			if len(defs) > 0 {
				f.Const().Defs(defs...)
			}
			f.Line()
		case len(def.AnyOf) > 0:
			emitUnion(f, name, def.AnyOf, false)
		case len(def.OneOf) > 0 && !isStringConstUnion(def):
			// Generic union generation for non-enum oneOf
			// Use the same implementation, but require exactly one variant
			emitUnion(f, name, def.OneOf, true)
		case ir.PrimaryType(def) == "object" && len(def.Properties) > 0:
			st := []Code{}
			req := map[string]struct{}{}
			for _, r := range def.Required {
				req[r] = struct{}{}
			}
			pkeys := make([]string, 0, len(def.Properties))
			for pk := range def.Properties {
				pkeys = append(pkeys, pk)
			}
			sort.Strings(pkeys)
			for _, pk := range pkeys {
				prop := def.Properties[pk]
				field := util.ToExportedField(pk)
				if prop.Description != "" {
					st = append(st, Comment(util.SanitizeComment(prop.Description)))
				}
				tag := pk
				if _, ok := req[pk]; !ok {
					// Default: omit if empty, except for specific always-present fields
					// Ensure InitializeResponse.authMethods is always encoded (even when empty)
					if !(name == "InitializeResponse" && pk == "authMethods") {
						tag = pk + ",omitempty"
					}
				}
				st = append(st, Id(field).Add(jenTypeForOptional(prop)).Tag(map[string]string{"json": tag}))
			}
			f.Type().Id(name).Struct(st...)
			f.Line()
		case ir.PrimaryType(def) == "string" || ir.PrimaryType(def) == "integer" || ir.PrimaryType(def) == "number" || ir.PrimaryType(def) == "boolean":
			f.Type().Id(name).Add(primitiveJenType(ir.PrimaryType(def)))
			f.Line()
		default:
			f.Comment(fmt.Sprintf("%s is a union or complex schema; represented generically.", name))
			f.Type().Id(name).Any()
			f.Line()
		}

		// validators for selected types
		// Note: oneOf union wrappers get a generic Validate emitted in emitUnion.
		if strings.HasSuffix(name, "Request") || strings.HasSuffix(name, "Response") || strings.HasSuffix(name, "Notification") || name == "ToolCallUpdate" {
			emitValidateJen(f, name, def)
		}
	}

	// Append Agent & Client interfaces from method groups
	groups := ir.BuildMethodGroups(schema, meta)

	// Agent
	agentMethods := []Code{}
	agentLoaderMethods := []Code{}
	agentExperimentalMethods := []Code{}
	for _, k := range ir.SortedKeys(meta.AgentMethods) {
		wire := meta.AgentMethods[k]
		mi := groups["agent|"+wire]
		if mi == nil {
			continue
		}
		target := &agentMethods
		switch mi.Binding {
		case ir.BindAgentLoader:
			target = &agentLoaderMethods
		case ir.BindAgentExperimental:
			target = &agentExperimentalMethods
		}
		if mi.Notif != "" {
			name := ir.DispatchMethodNameForNotification(k, mi.Notif)
			*target = append(*target, Id(name).Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Notif)).Error())
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			methodName := strings.TrimSuffix(mi.Req, "Request")
			if ir.IsNullResponse(schema.Defs[respName]) {
				*target = append(*target, Id(methodName).Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Req)).Error())
			} else {
				*target = append(*target, Id(methodName).Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Req)).Params(Id(respName), Error()))
			}
		}
	}
	f.Type().Id("Agent").Interface(agentMethods...)
	if len(agentLoaderMethods) > 0 {
		f.Comment("AgentLoader defines optional support for loading sessions. Implement and advertise the capability to enable 'session/load'.")
		f.Type().Id("AgentLoader").Interface(agentLoaderMethods...)
	}
	if len(agentExperimentalMethods) > 0 {
		f.Comment("AgentExperimental defines undocumented/experimental methods (x-docs-ignore). These may change or be removed without notice.")
		f.Type().Id("AgentExperimental").Interface(agentExperimentalMethods...)
	}

	// Client
	clientStable := []Code{}
	clientExperimental := []Code{}
	clientTerminal := []Code{}
	for _, k := range ir.SortedKeys(meta.ClientMethods) {
		wire := meta.ClientMethods[k]
		mi := groups["client|"+wire]
		if mi == nil {
			continue
		}
		target := &clientStable
		switch mi.Binding {
		case ir.BindClientExperimental:
			target = &clientExperimental
		case ir.BindClientTerminal:
			target = &clientTerminal
		}
		if mi.Notif != "" {
			name := ir.DispatchMethodNameForNotification(k, mi.Notif)
			*target = append(*target, Id(name).Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Notif)).Error())
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			methodName := strings.TrimSuffix(mi.Req, "Request")
			if ir.IsNullResponse(schema.Defs[respName]) {
				*target = append(*target, Id(methodName).Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Req)).Error())
			} else {
				*target = append(*target, Id(methodName).Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Req)).Params(Id(respName), Error()))
			}
		}
	}
	f.Type().Id("Client").Interface(clientStable...)
	if len(clientTerminal) > 0 {
		f.Comment("ClientTerminal defines terminal-related experimental methods (x-docs-ignore). Implement and advertise 'terminal: true' to enable 'terminal/*'.")
		f.Type().Id("ClientTerminal").Interface(clientTerminal...)
	}
	if len(clientExperimental) > 0 {
		f.Comment("ClientExperimental defines undocumented/experimental methods (x-docs-ignore) other than terminals. These may change or be removed without notice.")
		f.Type().Id("ClientExperimental").Interface(clientExperimental...)
	}

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		return err
	}
	return os.WriteFile(filepath.Join(outDir, "types_gen.go"), buf.Bytes(), 0o644)
}

func isStringConstUnion(def *load.Definition) bool {
	if def == nil || len(def.OneOf) == 0 {
		return false
	}
	for _, v := range def.OneOf {
		if v == nil || v.Const == nil {
			return false
		}
		if _, ok := v.Const.(string); !ok {
			return false
		}
	}
	return true
}

// emitValidateJen generates validators for selected types (logic unchanged).

func emitValidateJen(f *File, name string, def *load.Definition) {
	switch name {
	case "ToolCallUpdate":
		f.Func().Params(Id("t").Op("*").Id("ToolCallUpdate")).Id("Validate").Params().Params(Error()).Block(
			If(Id("t").Dot("ToolCallId").Op("==").Lit("")).Block(Return(Qual("fmt", "Errorf").Call(Lit("toolCallId is required")))),
			Return(Nil()),
		)
		return
	}
	if def != nil && ir.PrimaryType(def) == "object" {
		if !strings.HasSuffix(name, "Request") && !strings.HasSuffix(name, "Response") && !strings.HasSuffix(name, "Notification") {
			return
		}
		f.Func().Params(Id("v").Op("*").Id(name)).Id("Validate").Params().Params(Error()).BlockFunc(func(g *Group) {
			pkeys := make([]string, 0, len(def.Properties))
			for pk := range def.Properties {
				pkeys = append(pkeys, pk)
			}
			sort.Strings(pkeys)
			for _, propName := range pkeys {
				pDef := def.Properties[propName]
				required := slices.Contains(def.Required, propName)
				field := util.ToExportedField(propName)
				if required {
					switch ir.PrimaryType(pDef) {
					case "string":
						g.If(Id("v").Dot(field).Op("==").Lit("")).Block(Return(Qual("fmt", "Errorf").Call(Lit(propName + " is required"))))
					case "array":
						g.If(Id("v").Dot(field).Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit(propName + " is required"))))
					}
				}
			}
			g.Return(Nil())
		})
	}
}

// Type mapping helpers (unchanged behavior vs original)
func primitiveJenType(t string) Code {
	switch t {
	case "string":
		return String()
	case "integer":
		return Int()
	case "number":
		return Float64()
	case "boolean":
		return Bool()
	default:
		return Any()
	}
}

func jenTypeFor(d *load.Definition) Code {
	if d == nil {
		return Any()
	}
	if d.Ref != "" {
		if strings.HasPrefix(d.Ref, "#/$defs/") {
			return Id(d.Ref[len("#/$defs/"):])
		}
		return Any()
	}
	if len(d.Enum) > 0 {
		return String()
	}
	switch ir.PrimaryType(d) {
	case "string":
		return String()
	case "integer":
		return Int()
	case "number":
		return Float64()
	case "boolean":
		return Bool()
	case "array":
		return Index().Add(jenTypeFor(d.Items))
	case "object":
		if len(d.Properties) == 0 {
			return Map(String()).Any()
		}
		return Map(String()).Any()
	default:
		if len(d.AnyOf) > 0 || len(d.OneOf) > 0 {
			return Any()
		}
		return Any()
	}
}

// jenTypeForOptional maps unions that include null to pointer types where applicable.
func jenTypeForOptional(d *load.Definition) Code {
	if d == nil {
		return Any()
	}
	list := d.AnyOf
	if len(list) == 0 {
		list = d.OneOf
	}
	// Case: property type is a union like ["string","null"]
	if arr, ok := d.Type.([]any); ok && len(arr) == 2 {
		var other string
		for _, v := range arr {
			if s, ok2 := v.(string); ok2 {
				if s == "null" {
					continue
				}
				other = s
			}
		}
		switch other {
		case "string":
			return Op("*").String()
		case "integer":
			return Op("*").Int()
		case "number":
			return Op("*").Float64()
		case "boolean":
			return Op("*").Bool()
		}
	}
	if len(list) == 2 {
		var nonNull *load.Definition
		for _, e := range list {
			if e == nil {
				continue
			}
			if s, ok := e.Type.(string); ok && s == "null" {
				continue
			}
			if e.Const != nil {
				nn := *e
				nn.Type = "string"
				nonNull = &nn
			} else {
				nonNull = e
			}
		}
		if nonNull != nil {
			if nonNull.Ref != "" && strings.HasPrefix(nonNull.Ref, "#/$defs/") {
				return Op("*").Id(nonNull.Ref[len("#/$defs/"):])
			}
			switch ir.PrimaryType(nonNull) {
			case "string":
				return Op("*").String()
			case "integer":
				return Op("*").Int()
			case "number":
				return Op("*").Float64()
			case "boolean":
				return Op("*").Bool()
			}
		}
	}
	return jenTypeFor(d)
}

// emitAvailableCommandInputJen generates a concrete variant type for anyOf and a thin union wrapper
// that supports JSON unmarshal by probing object shape. Currently the schema defines one variant
// (title: UnstructuredCommandInput) with a required 'hint' field.
func emitUnion(f *File, name string, defs []*load.Definition, exactlyOne bool) {
	type variantInfo struct {
		fieldName  string
		typeName   string
		required   []string
		isObject   bool
		discValue  string
		constPairs [][2]string
		isNull     bool
	}
	variants := []variantInfo{}
	discKey := ""
	// discover discriminator key if present (any const property)
	for _, v := range defs {
		if v == nil {
			continue
		}
		for k, pd := range v.Properties {
			if pd != nil && pd.Const != nil {
				discKey = k
				break
			}
		}
		if discKey != "" {
			break
		}
	}
	for idx, v := range defs {
		if v == nil {
			continue
		}
		// Detect null-only variant
		isNull := false
		if s, ok := v.Type.(string); ok && s == "null" {
			isNull = true
		}
		tname := v.Title
		if tname == "" {
			if v.Ref != "" && strings.HasPrefix(v.Ref, "#/$defs/") {
				tname = v.Ref[len("#/$defs/"):]
			} else {
				if discKey != "" {
					if pd := v.Properties[discKey]; pd != nil && pd.Const != nil {
						s := fmt.Sprint(pd.Const)
						tname = name + util.ToExportedField(s)
					}
				}
				if tname == "" {
					tname = name + fmt.Sprintf("Variant%d", idx+1)
				}
			}
		}
		fieldName := tname
		dv := ""
		if discKey != "" {
			if pd := v.Properties[discKey]; pd != nil && pd.Const != nil {
				s := fmt.Sprint(pd.Const)
				fieldName = util.ToExportedField(s)
				dv = s
			}
		}
		isObj := len(v.Properties) > 0
		// collect const properties (e.g., type, outcome)
		consts := [][2]string{}
		for pk, pd := range v.Properties {
			if pd != nil && pd.Const != nil {
				if s, ok := pd.Const.(string); ok {
					consts = append(consts, [2]string{pk, s})
				}
			}
		}
		if (isObj || isNull) && v.Ref == "" {
			st := []Code{}
			if !isNull {
				req := map[string]struct{}{}
				for _, r := range v.Required {
					req[r] = struct{}{}
				}
				pkeys := make([]string, 0, len(v.Properties))
				for pk := range v.Properties {
					pkeys = append(pkeys, pk)
				}
				sort.Strings(pkeys)
				if v.Description != "" {
					f.Comment(util.SanitizeComment(v.Description))
				}
				for _, pk := range pkeys {
					pDef := v.Properties[pk]
					field := util.ToExportedField(pk)
					if pDef.Description != "" {
						st = append(st, Comment(util.SanitizeComment(pDef.Description)))
					}
					tag := pk
					if _, ok := req[pk]; !ok {
						tag = pk + ",omitempty"
					}
					st = append(st, Id(field).Add(jenTypeForOptional(pDef)).Tag(map[string]string{"json": tag}))
				}
			}
			f.Type().Id(tname).Struct(st...)
			f.Line()
		}
		variants = append(variants, variantInfo{fieldName: fieldName, typeName: tname, required: v.Required, isObject: isObj, discValue: dv, constPairs: consts, isNull: isNull})
	}
	// wrapper
	st := []Code{}
	for _, vi := range variants {
		st = append(st, Id(vi.fieldName).Op("*").Id(vi.typeName).Tag(map[string]string{"json": "-"}))
	}
	f.Type().Id(name).Struct(st...)
	f.Line()
	// Unmarshal
	f.Func().Params(Id("u").Op("*").Id(name)).Id("UnmarshalJSON").Params(Id("b").Index().Byte()).Error().BlockFunc(func(g *Group) {
		// Handle literal null if a null-only variant exists
		{
			varNullHandled := false
			for _, vi := range variants {
				if vi.isNull {
					// emit once for the first null variant
					if !varNullHandled {
						g.If(Id("string").Call(Id("b")).Op("==").Lit("null")).Block(
							Var().Id("v").Id(vi.typeName),
							Id("u").Dot(vi.fieldName).Op("=").Op("&").Id("v"),
							Return(Nil()),
						)
						varNullHandled = true
					}
				}
			}
		}
		g.Var().Id("m").Map(String()).Qual("encoding/json", "RawMessage")
		g.If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("m")), Id("err").Op("!=").Nil()).Block(Return(Id("err")))
		// Prefer discriminator-based dispatch when available (e.g. "type", "outcome")
		if discKey != "" {
			g.BlockFunc(func(h *Group) {
				h.Var().Id("disc").String()
				h.If(List(Id("v"), Id("ok")).Op(":=").Id("m").Index(Lit(discKey)), Id("ok")).Block(
					Qual("encoding/json", "Unmarshal").Call(Id("v"), Op("&").Id("disc")),
				)
				h.Switch(Id("disc")).BlockFunc(func(sw *Group) {
					for _, vi := range variants {
						if vi.discValue != "" {
							sw.Case(Lit(vi.discValue)).Block(
								Var().Id("v").Id(vi.typeName),
								If(Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")).Op("!=").Nil()).Block(Return(Qual("errors", "New").Call(Lit("invalid variant payload")))),
								Id("u").Dot(vi.fieldName).Op("=").Op("&").Id("v"),
								Return(Nil()),
							)
						}
					}
				})
			})
		}
		// Special-case: EmbeddedResourceResource variants distinguished by keys
		if name == "EmbeddedResourceResource" {
			g.If(List(Id("_"), Id("ok")).Op(":=").Id("m").Index(Lit("text")), Id("ok")).Block(
				Var().Id("v").Id("TextResourceContents"),
				If(Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")).Op("!=").Nil()).Block(Return(Qual("errors", "New").Call(Lit("invalid variant payload")))),
				Id("u").Dot("TextResourceContents").Op("=").Op("&").Id("v"),
				Return(Nil()),
			)
			g.If(List(Id("_"), Id("ok")).Op(":=").Id("m").Index(Lit("blob")), Id("ok")).Block(
				Var().Id("v").Id("BlobResourceContents"),
				If(Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")).Op("!=").Nil()).Block(Return(Qual("errors", "New").Call(Lit("invalid variant payload")))),
				Id("u").Dot("BlobResourceContents").Op("=").Op("&").Id("v"),
				Return(Nil()),
			)
		}
		// required-key match
		for _, vi := range variants {
			if vi.isObject && len(vi.required) > 0 {
				g.BlockFunc(func(h *Group) {
					h.Var().Id("v").Id(vi.typeName)
					h.Var().Id("match").Bool().Op("=").Lit(true)
					for _, rk := range vi.required {
						h.If(List(Id("_"), Id("ok")).Op(":=").Id("m").Index(Lit(rk)), Op("!").Id("ok")).Block(Id("match").Op("=").Lit(false))
					}
					h.If(Id("match")).Block(
						If(Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")).Op("!=").Nil()).Block(Return(Qual("errors", "New").Call(Lit("invalid variant payload")))),
						Id("u").Dot(vi.fieldName).Op("=").Op("&").Id("v"),
						Return(Nil()),
					)
				})
			}
		}
		// fallback: try decode sequentially
		for _, vi := range variants {
			g.Block(
				Var().Id("v").Id(vi.typeName),
				If(Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")).Op("==").Nil()).Block(
					Id("u").Dot(vi.fieldName).Op("=").Op("&").Id("v"),
					Return(Nil()),
				),
			)
		}
		g.Return(Nil())
	})
	// Marshal
	f.Func().Params(Id("u").Id(name)).Id("MarshalJSON").Params().Params(Index().Byte(), Error()).BlockFunc(func(g *Group) {
		for _, vi := range variants {
			g.If(Id("u").Dot(vi.fieldName).Op("!=").Nil()).BlockFunc(func(gg *Group) {
				// Null-only variant encodes to JSON null
				if vi.isNull {
					gg.Return(Qual("encoding/json", "Marshal").Call(Nil()))
				}
				// Marshal variant to map for discriminant injection and shaping
				gg.Var().Id("m").Map(String()).Any()
				gg.List(Id("_b"), Id("_e")).Op(":=").Qual("encoding/json", "Marshal").Call(Op("*").Id("u").Dot(vi.fieldName))
				gg.If(Id("_e").Op("!=").Nil()).Block(Return(Index().Byte().Values(), Id("_e")))
				gg.If(Qual("encoding/json", "Unmarshal").Call(Id("_b"), Op("&").Id("m")).Op("!=").Nil()).Block(Return(Index().Byte().Values(), Qual("errors", "New").Call(Lit("invalid variant payload"))))
				// Inject const discriminants
				if len(vi.constPairs) > 0 {
					for _, kv := range vi.constPairs {
						gg.Id("m").Index(Lit(kv[0])).Op("=").Lit(kv[1])
					}
				}
				// Special shaping for ContentBlock variants to preserve exact wire JSON
				if name == "ContentBlock" {
					switch vi.discValue {
					case "text":
						gg.Block(
							Var().Id("nm").Map(String()).Any(),
							Id("nm").Op("=").Make(Map(String()).Any()),
							Id("nm").Index(Lit("type")).Op("=").Lit("text"),
							Id("nm").Index(Lit("text")).Op("=").Id("m").Index(Lit("text")),
							Return(Qual("encoding/json", "Marshal").Call(Id("nm"))),
						)
					case "image":
						gg.Block(
							Var().Id("nm").Map(String()).Any(),
							Id("nm").Op("=").Make(Map(String()).Any()),
							Id("nm").Index(Lit("type")).Op("=").Lit("image"),
							Id("nm").Index(Lit("data")).Op("=").Id("m").Index(Lit("data")),
							Id("nm").Index(Lit("mimeType")).Op("=").Id("m").Index(Lit("mimeType")),
							// Only include uri if present; do not emit null
							If(List(Id("_v"), Id("_ok")).Op(":=").Id("m").Index(Lit("uri")), Id("_ok")).Block(
								Id("nm").Index(Lit("uri")).Op("=").Id("_v"),
							),
							Return(Qual("encoding/json", "Marshal").Call(Id("nm"))),
						)
					case "audio":
						gg.Block(
							Var().Id("nm").Map(String()).Any(),
							Id("nm").Op("=").Make(Map(String()).Any()),
							Id("nm").Index(Lit("type")).Op("=").Lit("audio"),
							Id("nm").Index(Lit("data")).Op("=").Id("m").Index(Lit("data")),
							Id("nm").Index(Lit("mimeType")).Op("=").Id("m").Index(Lit("mimeType")),
							Return(Qual("encoding/json", "Marshal").Call(Id("nm"))),
						)
					case "resource_link":
						gg.BlockFunc(func(b *Group) {
							b.Var().Id("nm").Map(String()).Any()
							b.Id("nm").Op("=").Make(Map(String()).Any())
							b.Id("nm").Index(Lit("type")).Op("=").Lit("resource_link")
							b.Id("nm").Index(Lit("name")).Op("=").Id("m").Index(Lit("name"))
							b.Id("nm").Index(Lit("uri")).Op("=").Id("m").Index(Lit("uri"))
							// Only include optional keys if present
							b.If(List(Id("v1"), Id("ok1")).Op(":=").Id("m").Index(Lit("description")), Id("ok1")).Block(
								Id("nm").Index(Lit("description")).Op("=").Id("v1"),
							)
							b.If(List(Id("v2"), Id("ok2")).Op(":=").Id("m").Index(Lit("mimeType")), Id("ok2")).Block(
								Id("nm").Index(Lit("mimeType")).Op("=").Id("v2"),
							)
							b.If(List(Id("v3"), Id("ok3")).Op(":=").Id("m").Index(Lit("size")), Id("ok3")).Block(
								Id("nm").Index(Lit("size")).Op("=").Id("v3"),
							)
							b.If(List(Id("v4"), Id("ok4")).Op(":=").Id("m").Index(Lit("title")), Id("ok4")).Block(
								Id("nm").Index(Lit("title")).Op("=").Id("v4"),
							)
							b.Return(Qual("encoding/json", "Marshal").Call(Id("nm")))
						})
					case "resource":
						gg.Block(
							Var().Id("nm").Map(String()).Any(),
							Id("nm").Op("=").Make(Map(String()).Any()),
							Id("nm").Index(Lit("type")).Op("=").Lit("resource"),
							Id("nm").Index(Lit("resource")).Op("=").Id("m").Index(Lit("resource")),
							Return(Qual("encoding/json", "Marshal").Call(Id("nm"))),
						)
					}
				}
				// default: remarshal possibly with injected discriminant
				if name != "ContentBlock" {
					gg.Return(Qual("encoding/json", "Marshal").Call(Id("m")))
				}
			})
		}
		g.Return(Index().Byte().Values(), Nil())
	})
	f.Line()

	// Generic validator for oneOf unions: exactly one variant must be set
	if exactlyOne {
		f.Func().Params(Id("u").Op("*").Id(name)).Id("Validate").Params().Params(Error()).BlockFunc(func(g *Group) {
			g.Var().Id("count").Int()
			for _, vi := range variants {
				g.If(Id("u").Dot(vi.fieldName).Op("!=").Nil()).Block(Id("count").Op("++"))
			}
			g.If(Id("count").Op("!=").Lit(1)).Block(
				Return(Qual("errors", "New").Call(Lit(name + " must have exactly one variant set"))),
			)
			g.Return(Nil())
		})
		f.Line()
	}
}
