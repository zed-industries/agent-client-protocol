package emit

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"sort"
	"strings"

	"github.com/zed-industries/agent-client-protocol/go/cmd/generate/internal/ir"
	"github.com/zed-industries/agent-client-protocol/go/cmd/generate/internal/load"
	"github.com/zed-industries/agent-client-protocol/go/cmd/generate/internal/util"
)

// WriteTypesJen emits go/types_gen.go with all types and the Agent/Client interfaces.
func WriteTypesJen(outDir string, schema *load.Schema, meta *load.Meta) error {
	f := NewFile("acp")
	f.HeaderComment("Code generated by acp-go-generator; DO NOT EDIT.")

	// Deterministic order
	keys := make([]string, 0, len(schema.Defs))
	for k := range schema.Defs {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, name := range keys {
		def := schema.Defs[name]
		if def == nil {
			continue
		}

		if def.Description != "" {
			f.Comment(util.SanitizeComment(def.Description))
		}

		switch {
		case len(def.Enum) > 0:
			f.Type().Id(name).String()
			defs := []Code{}
			for _, v := range def.Enum {
				s := fmt.Sprint(v)
				defs = append(defs, Id(util.ToEnumConst(name, s)).Id(name).Op("=").Lit(s))
			}
			if len(defs) > 0 {
				f.Const().Defs(defs...)
			}
			f.Line()
		case isStringConstUnion(def):
			f.Type().Id(name).String()
			defs := []Code{}
			for _, v := range def.OneOf {
				if v != nil && v.Const != nil {
					s := fmt.Sprint(v.Const)
					defs = append(defs, Id(util.ToEnumConst(name, s)).Id(name).Op("=").Lit(s))
				}
			}
			if len(defs) > 0 {
				f.Const().Defs(defs...)
			}
			f.Line()
		case len(def.AnyOf) > 0:
			emitUnion(f, name, def.AnyOf, false)
		case len(def.OneOf) > 0 && !isStringConstUnion(def):
			// Generic union generation for non-enum oneOf
			// Use the same implementation, but require exactly one variant
			emitUnion(f, name, def.OneOf, true)
		case ir.PrimaryType(def) == "object" && len(def.Properties) > 0:
			st := []Code{}
			req := map[string]struct{}{}
			for _, r := range def.Required {
				req[r] = struct{}{}
			}
			pkeys := make([]string, 0, len(def.Properties))
			for pk := range def.Properties {
				pkeys = append(pkeys, pk)
			}
			sort.Strings(pkeys)
			// Track fields with schema defaults for generic (de)serialization
			type DefaultKind int
			const (
				KindNone DefaultKind = iota
				KindScalar
				KindArray
				KindObject
			)
			type defaultProp struct {
				fieldName   string
				propName    string
				defaultJSON string
				kind        DefaultKind
				allowNull   bool
				nilable     bool // whether zero-value is nil (slice/map)
			}
			defaults := []defaultProp{}

			for _, pk := range pkeys {
				prop := def.Properties[pk]
				field := util.ToExportedField(pk)
				if prop.Description != "" {
					st = append(st, Comment(util.SanitizeComment(prop.Description)))
				}
				tag := pk
				// Detect defaults generically
				var dp *defaultProp
				if prop.Default != nil {
					// Compute kind from default value
					k := defaultKindOf(prop.Default)
					// Whether field zero is nil (slice/map) for Marshal fill-in
					nilable := ir.PrimaryType(prop) == "array" || (ir.PrimaryType(prop) == "object" && len(prop.Properties) == 0 && prop.Ref == "")
					// Capture canonical JSON of default
					defJSON := "null"
					if b, err := json.Marshal(prop.Default); err == nil {
						defJSON = string(b)
					}
					dp = &defaultProp{
						fieldName:   field,
						propName:    pk,
						defaultJSON: defJSON,
						kind:        DefaultKind(k),
						allowNull:   includesNull(prop),
						nilable:     nilable,
					}
					defaults = append(defaults, *dp)
				}
				if _, ok := req[pk]; !ok {
					// Default: omit if empty for optional fields.
					// Keep always-present behavior only for defaults where the zero value is nil (slice/map).
					// For typed object defaults (non-nilable), still allow omission on the wire.
					if dp == nil || (dp.kind != KindArray && dp.kind != KindObject) || (dp != nil && !dp.nilable) {
						tag = pk + ",omitempty"
					}
				}
				// Emit an additional comment line indicating the default, if any.
				if dp != nil && dp.defaultJSON != "null" {
					// Insert an empty comment line before default comment (visual separator)
					if prop.Description != "" {
						st = append(st, Comment(""))
					}
					st = append(st, Comment(util.SanitizeComment(fmt.Sprintf("Defaults to %s if unset.", dp.defaultJSON))))
				}
				st = append(st, Id(field).Add(jenTypeForOptional(prop)).Tag(map[string]string{"json": tag}))
			}
			f.Type().Id(name).Struct(st...)
			f.Line()

			// If the struct has any fields with schema defaults, synthesize MarshalJSON and UnmarshalJSON
			if len(defaults) > 0 {
				// MarshalJSON: coerce nil slices to empty slices before encoding
				f.Func().Params(Id("v").Id(name)).Id("MarshalJSON").Params().Params(Index().Byte(), Error()).BlockFunc(func(g *Group) {
					g.Type().Id("Alias").Id(name)
					g.Var().Id("a").Id("Alias")
					g.Id("a").Op("=").Id("Alias").Call(Id("v"))
					for _, dp := range defaults {
						// For array/map defaults: if zero is nil, fill with default JSON when nil
						if dp.kind == KindArray || dp.kind == KindObject {
							if dp.nilable {
								g.If(Id("a").Dot(dp.fieldName).Op("==").Nil()).Block(
									Qual("encoding/json", "Unmarshal").Call(Index().Byte().Parens(Lit(dp.defaultJSON)), Op("&").Id("a").Dot(dp.fieldName)),
								)
							}
						}
						// For typed object defaults (non-nilable), we keep Option A: do not inject values on encode.
					}
					g.Return(Qual("encoding/json", "Marshal").Call(Id("a")))
				})
				f.Line()

				// UnmarshalJSON: apply defaults when field is missing or null (and schema doesn't include null)
				f.Func().Params(Id("v").Op("*").Id(name)).Id("UnmarshalJSON").Params(Id("b").Index().Byte()).Error().BlockFunc(func(g *Group) {
					g.Var().Id("m").Map(String()).Qual("encoding/json", "RawMessage")
					g.If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("m")), Id("err").Op("!=").Nil()).Block(Return(Id("err")))
					g.Type().Id("Alias").Id(name)
					g.Var().Id("a").Id("Alias")
					g.If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("a")), Id("err").Op("!=").Nil()).Block(Return(Id("err")))
					for _, dp := range defaults {
						g.BlockFunc(func(h *Group) {
							h.List(Id("_rm"), Id("_ok")).Op(":=").Id("m").Index(Lit(dp.propName))
							// Apply default when missing, or when null and null is not allowed
							if dp.allowNull {
								h.If(Op("!").Id("_ok")).Block(
									Qual("encoding/json", "Unmarshal").Call(Index().Byte().Parens(Lit(dp.defaultJSON)), Op("&").Id("a").Dot(dp.fieldName)),
								)
							} else {
								h.If(Op("!").Id("_ok").Op("||").Parens(Id("string").Call(Id("_rm")).Op("==").Lit("null"))).Block(
									Qual("encoding/json", "Unmarshal").Call(Index().Byte().Parens(Lit(dp.defaultJSON)), Op("&").Id("a").Dot(dp.fieldName)),
								)
							}
						})
					}
					g.Op("*").Id("v").Op("=").Id(name).Call(Id("a"))
					g.Return(Nil())
				})
				f.Line()
			}
		case ir.PrimaryType(def) == "string" || ir.PrimaryType(def) == "integer" || ir.PrimaryType(def) == "number" || ir.PrimaryType(def) == "boolean":
			f.Type().Id(name).Add(primitiveJenType(ir.PrimaryType(def)))
			f.Line()
		case ir.PrimaryType(def) == "object" && len(def.Properties) == 0:
			// Empty object shape: emit a concrete empty struct so methods can be defined
			// and the wire encoding is consistently {} rather than null.
			f.Type().Id(name).Struct()
			f.Line()
		default:
			f.Comment(fmt.Sprintf("%s is a union or complex schema; represented generically.", name))
			f.Type().Id(name).Any()
			f.Line()
		}

		// validators for selected types
		// Note: oneOf union wrappers get a generic Validate emitted in emitUnion.
		if strings.HasSuffix(name, "Request") || strings.HasSuffix(name, "Response") || strings.HasSuffix(name, "Notification") || name == "ToolCallUpdate" {
			emitValidateJen(f, name, def)
		}
	}

	// Append Agent & Client interfaces from method groups
	groups := ir.BuildMethodGroups(schema, meta)

	// Agent
	agentMethods := []Code{}
	agentLoaderMethods := []Code{}
	agentExperimentalMethods := []Code{}
	for _, k := range ir.SortedKeys(meta.AgentMethods) {
		wire := meta.AgentMethods[k]
		mi := groups["agent|"+wire]
		if mi == nil {
			continue
		}
		target := &agentMethods
		switch mi.Binding {
		case ir.BindAgentLoader:
			target = &agentLoaderMethods
		case ir.BindAgentExperimental:
			target = &agentExperimentalMethods
		}
		if mi.Notif != "" {
			name := ir.DispatchMethodNameForNotification(k, mi.Notif)
			*target = append(*target, Id(name).Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Notif)).Error())
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			methodName := strings.TrimSuffix(mi.Req, "Request")
			if ir.IsNullResponse(schema.Defs[respName]) {
				*target = append(*target, Id(methodName).Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Req)).Error())
			} else {
				*target = append(*target, Id(methodName).Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Req)).Params(Id(respName), Error()))
			}
		}
	}
	f.Type().Id("Agent").Interface(agentMethods...)
	if len(agentLoaderMethods) > 0 {
		f.Comment("AgentLoader defines optional support for loading sessions. Implement and advertise the capability to enable 'session/load'.")
		f.Type().Id("AgentLoader").Interface(agentLoaderMethods...)
	}
	// Always emit AgentExperimental, even if empty.
	f.Comment("AgentExperimental defines unstable methods that are not part of the official spec. These may change or be removed without notice.")
	f.Type().Id("AgentExperimental").Interface(agentExperimentalMethods...)

	// Client
	clientStable := []Code{}
	clientExperimental := []Code{}
	clientTerminal := []Code{}
	for _, k := range ir.SortedKeys(meta.ClientMethods) {
		wire := meta.ClientMethods[k]
		mi := groups["client|"+wire]
		if mi == nil {
			continue
		}
		target := &clientStable
		switch mi.Binding {
		case ir.BindClientExperimental:
			target = &clientExperimental
		case ir.BindClientTerminal:
			target = &clientTerminal
		}
		if mi.Notif != "" {
			name := ir.DispatchMethodNameForNotification(k, mi.Notif)
			*target = append(*target, Id(name).Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Notif)).Error())
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			methodName := strings.TrimSuffix(mi.Req, "Request")
			if ir.IsNullResponse(schema.Defs[respName]) {
				*target = append(*target, Id(methodName).Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Req)).Error())
			} else {
				*target = append(*target, Id(methodName).Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Req)).Params(Id(respName), Error()))
			}
		}
	}
	f.Type().Id("Client").Interface(clientStable...)
	if len(clientTerminal) > 0 {
		f.Comment("ClientTerminal defines terminal-related experimental methods (x-docs-ignore). Implement and advertise 'terminal: true' to enable 'terminal/*'.")
		f.Type().Id("ClientTerminal").Interface(clientTerminal...)
	}
	// Always emit ClientExperimental, even if empty.
	f.Comment("ClientExperimental defines unstable methods that are not part of the official spec. These may change or be removed without notice.")
	f.Type().Id("ClientExperimental").Interface(clientExperimental...)

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		return err
	}
	return os.WriteFile(filepath.Join(outDir, "types_gen.go"), buf.Bytes(), 0o644)
}

func isStringConstUnion(def *load.Definition) bool {
	if def == nil || len(def.OneOf) == 0 {
		return false
	}
	for _, v := range def.OneOf {
		if v == nil || v.Const == nil {
			return false
		}
		if _, ok := v.Const.(string); !ok {
			return false
		}
	}
	return true
}

// emitValidateJen generates validators for selected types (logic unchanged).

func emitValidateJen(f *File, name string, def *load.Definition) {
	switch name {
	case "ToolCallUpdate":
		f.Func().Params(Id("t").Op("*").Id("ToolCallUpdate")).Id("Validate").Params().Params(Error()).Block(
			If(Id("t").Dot("ToolCallId").Op("==").Lit("")).Block(Return(Qual("fmt", "Errorf").Call(Lit("toolCallId is required")))),
			Return(Nil()),
		)
		return
	}
	if def != nil && ir.PrimaryType(def) == "object" {
		if !strings.HasSuffix(name, "Request") && !strings.HasSuffix(name, "Response") && !strings.HasSuffix(name, "Notification") {
			return
		}
		f.Func().Params(Id("v").Op("*").Id(name)).Id("Validate").Params().Params(Error()).BlockFunc(func(g *Group) {
			pkeys := make([]string, 0, len(def.Properties))
			for pk := range def.Properties {
				pkeys = append(pkeys, pk)
			}
			sort.Strings(pkeys)
			for _, propName := range pkeys {
				pDef := def.Properties[propName]
				required := slices.Contains(def.Required, propName)
				field := util.ToExportedField(propName)
				if required {
					switch ir.PrimaryType(pDef) {
					case "string":
						g.If(Id("v").Dot(field).Op("==").Lit("")).Block(Return(Qual("fmt", "Errorf").Call(Lit(propName + " is required"))))
					case "array":
						g.If(Id("v").Dot(field).Op("==").Nil()).Block(Return(Qual("fmt", "Errorf").Call(Lit(propName + " is required"))))
					}
				}
			}
			g.Return(Nil())
		})
	}
}

// Type mapping helpers (unchanged behavior vs original)
func primitiveJenType(t string) Code {
	switch t {
	case "string":
		return String()
	case "integer":
		return Int()
	case "number":
		return Float64()
	case "boolean":
		return Bool()
	default:
		return Any()
	}
}

// defaultKindOf classifies the JSON Schema default value into a coarse kind.
func defaultKindOf(val any) int {
	switch val.(type) {
	case nil:
		return 0 // KindNone
	case []any:
		return 2 // KindArray
	case map[string]any:
		return 3 // KindObject
	case string, float64, bool:
		return 1 // KindScalar
	default:
		// Fallback: classify by fmt string
		s := fmt.Sprint(val)
		if strings.HasPrefix(s, "[") {
			return 2
		}
		if strings.HasPrefix(s, "map[") || strings.HasPrefix(s, "{") {
			return 3
		}
		return 1
	}
}

// includesNull reports whether the property's type union contains null.
func includesNull(d *load.Definition) bool {
	if d == nil || d.Type == nil {
		return false
	}
	if arr, ok := d.Type.([]any); ok {
		for _, v := range arr {
			if s, ok2 := v.(string); ok2 && s == "null" {
				return true
			}
		}
	}
	return false
}

func jenTypeFor(d *load.Definition) Code {
	if d == nil {
		return Any()
	}
	if d.Ref != "" {
		if strings.HasPrefix(d.Ref, "#/$defs/") {
			return Id(d.Ref[len("#/$defs/"):])
		}
		return Any()
	}
	if len(d.Enum) > 0 {
		return String()
	}
	switch ir.PrimaryType(d) {
	case "string":
		return String()
	case "integer":
		return Int()
	case "number":
		return Float64()
	case "boolean":
		return Bool()
	case "array":
		return Index().Add(jenTypeFor(d.Items))
	case "object":
		if len(d.Properties) == 0 {
			return Map(String()).Any()
		}
		return Map(String()).Any()
	default:
		if len(d.AnyOf) > 0 || len(d.OneOf) > 0 {
			return Any()
		}
		return Any()
	}
}

// jenTypeForOptional maps unions that include null to pointer types where applicable.
func jenTypeForOptional(d *load.Definition) Code {
	if d == nil {
		return Any()
	}
	list := d.AnyOf
	if len(list) == 0 {
		list = d.OneOf
	}
	// Case: property type is a union like ["string","null"]
	if arr, ok := d.Type.([]any); ok && len(arr) == 2 {
		var other string
		for _, v := range arr {
			if s, ok2 := v.(string); ok2 {
				if s == "null" {
					continue
				}
				other = s
			}
		}
		switch other {
		case "string":
			return Op("*").String()
		case "integer":
			return Op("*").Int()
		case "number":
			return Op("*").Float64()
		case "boolean":
			return Op("*").Bool()
		}
	}
	if len(list) == 2 {
		var nonNull *load.Definition
		for _, e := range list {
			if e == nil {
				continue
			}
			if s, ok := e.Type.(string); ok && s == "null" {
				continue
			}
			if e.Const != nil {
				nn := *e
				nn.Type = "string"
				nonNull = &nn
			} else {
				nonNull = e
			}
		}
		if nonNull != nil {
			if nonNull.Ref != "" && strings.HasPrefix(nonNull.Ref, "#/$defs/") {
				return Op("*").Id(nonNull.Ref[len("#/$defs/"):])
			}
			switch ir.PrimaryType(nonNull) {
			case "string":
				return Op("*").String()
			case "integer":
				return Op("*").Int()
			case "number":
				return Op("*").Float64()
			case "boolean":
				return Op("*").Bool()
			}
		}
	}
	return jenTypeFor(d)
}

// emitAvailableCommandInputJen generates a concrete variant type for anyOf and a thin union wrapper
// that supports JSON unmarshal by probing object shape. Currently the schema defines one variant
// (title: UnstructuredCommandInput) with a required 'hint' field.
func emitUnion(f *File, name string, defs []*load.Definition, exactlyOne bool) {
	type variantInfo struct {
		fieldName  string
		typeName   string
		required   []string
		isObject   bool
		discValue  string
		constPairs [][2]string
		isNull     bool
	}
	variants := []variantInfo{}
	discKey := ""
	// discover discriminator key if present (any const property)
	for _, v := range defs {
		if v == nil {
			continue
		}
		for k, pd := range v.Properties {
			if pd != nil && pd.Const != nil {
				discKey = k
				break
			}
		}
		if discKey != "" {
			break
		}
	}
	for idx, v := range defs {
		if v == nil {
			continue
		}
		// Detect null-only variant
		isNull := false
		if s, ok := v.Type.(string); ok && s == "null" {
			isNull = true
		}
		// Determine type name: prefer $ref target name when present; do not treat Title as a rename for $ref.
		tname := ""
		if v.Ref != "" && strings.HasPrefix(v.Ref, "#/$defs/") {
			tname = v.Ref[len("#/$defs/"):]
		} else if v.Title != "" {
			tname = v.Title
		} else {
			if discKey != "" {
				if pd := v.Properties[discKey]; pd != nil && pd.Const != nil {
					s := fmt.Sprint(pd.Const)
					tname = name + util.ToExportedField(s)
				}
			}
			if tname == "" {
				tname = name + fmt.Sprintf("Variant%d", idx+1)
			}
		}
		// Ensure Title-derived names are exported (e.g., "stdio" -> "Stdio").
		tname = util.ToExportedField(tname)
		fieldName := util.ToExportedField(tname)
		dv := ""
		if discKey != "" {
			if pd := v.Properties[discKey]; pd != nil && pd.Const != nil {
				s := fmt.Sprint(pd.Const)
				fieldName = util.ToExportedField(s)
				dv = s
			}
		}
		isObj := len(v.Properties) > 0
		// Skip phantom variants that have neither $ref nor object shape nor null (e.g., placeholders with only a title)
		if !isObj && v.Ref == "" && !isNull {
			continue
		}
		// collect const properties (e.g., type, outcome)
		consts := [][2]string{}
		for pk, pd := range v.Properties {
			if pd != nil && pd.Const != nil {
				if s, ok := pd.Const.(string); ok {
					consts = append(consts, [2]string{pk, s})
				}
			}
		}
		if (isObj || isNull) && v.Ref == "" {
			st := []Code{}
			if !isNull {
				req := map[string]struct{}{}
				for _, r := range v.Required {
					req[r] = struct{}{}
				}
				pkeys := make([]string, 0, len(v.Properties))
				for pk := range v.Properties {
					pkeys = append(pkeys, pk)
				}
				sort.Strings(pkeys)
				if v.Description != "" {
					f.Comment(util.SanitizeComment(v.Description))
				}
				for _, pk := range pkeys {
					pDef := v.Properties[pk]
					field := util.ToExportedField(pk)
					if pDef.Description != "" {
						st = append(st, Comment(util.SanitizeComment(pDef.Description)))
					}
					tag := pk
					if _, ok := req[pk]; !ok {
						tag = pk + ",omitempty"
					}
					st = append(st, Id(field).Add(jenTypeForOptional(pDef)).Tag(map[string]string{"json": tag}))
				}
			}
			f.Type().Id(tname).Struct(st...)
			f.Line()
		}
		variants = append(variants, variantInfo{fieldName: fieldName, typeName: tname, required: v.Required, isObject: isObj, discValue: dv, constPairs: consts, isNull: isNull})
	}
	// wrapper
	st := []Code{}
	for _, vi := range variants {
		st = append(st, Id(vi.fieldName).Op("*").Id(vi.typeName).Tag(map[string]string{"json": "-"}))
	}
	f.Type().Id(name).Struct(st...)
	f.Line()
	// Unmarshal
	f.Func().Params(Id("u").Op("*").Id(name)).Id("UnmarshalJSON").Params(Id("b").Index().Byte()).Error().BlockFunc(func(g *Group) {
		// Handle literal null if a null-only variant exists
		{
			varNullHandled := false
			for _, vi := range variants {
				if vi.isNull {
					// emit once for the first null variant
					if !varNullHandled {
						g.If(Id("string").Call(Id("b")).Op("==").Lit("null")).Block(
							Var().Id("v").Id(vi.typeName),
							Id("u").Dot(vi.fieldName).Op("=").Op("&").Id("v"),
							Return(Nil()),
						)
						varNullHandled = true
					}
				}
			}
		}
		g.Var().Id("m").Map(String()).Qual("encoding/json", "RawMessage")
		g.If(List(Id("err")).Op(":=").Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("m")), Id("err").Op("!=").Nil()).Block(Return(Id("err")))
		// Prefer discriminator-based dispatch when available (e.g. "type", "outcome")
		if discKey != "" {
			g.BlockFunc(func(h *Group) {
				h.Var().Id("disc").String()
				h.If(List(Id("v"), Id("ok")).Op(":=").Id("m").Index(Lit(discKey)), Id("ok")).Block(
					Qual("encoding/json", "Unmarshal").Call(Id("v"), Op("&").Id("disc")),
				)
				h.Switch(Id("disc")).BlockFunc(func(sw *Group) {
					for _, vi := range variants {
						if vi.discValue != "" {
							sw.Case(Lit(vi.discValue)).Block(
								Var().Id("v").Id(vi.typeName),
								If(Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")).Op("!=").Nil()).Block(Return(Qual("errors", "New").Call(Lit("invalid variant payload")))),
								Id("u").Dot(vi.fieldName).Op("=").Op("&").Id("v"),
								Return(Nil()),
							)
						}
					}
				})
			})
		}
		// Special-case: EmbeddedResourceResource variants distinguished by keys
		if name == "EmbeddedResourceResource" {
			g.If(List(Id("_"), Id("ok")).Op(":=").Id("m").Index(Lit("text")), Id("ok")).Block(
				Var().Id("v").Id("TextResourceContents"),
				If(Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")).Op("!=").Nil()).Block(Return(Qual("errors", "New").Call(Lit("invalid variant payload")))),
				Id("u").Dot("TextResourceContents").Op("=").Op("&").Id("v"),
				Return(Nil()),
			)
			g.If(List(Id("_"), Id("ok")).Op(":=").Id("m").Index(Lit("blob")), Id("ok")).Block(
				Var().Id("v").Id("BlobResourceContents"),
				If(Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")).Op("!=").Nil()).Block(Return(Qual("errors", "New").Call(Lit("invalid variant payload")))),
				Id("u").Dot("BlobResourceContents").Op("=").Op("&").Id("v"),
				Return(Nil()),
			)
		}
		// required-key match
		for _, vi := range variants {
			if vi.isObject && len(vi.required) > 0 {
				g.BlockFunc(func(h *Group) {
					h.Var().Id("v").Id(vi.typeName)
					h.Var().Id("match").Bool().Op("=").Lit(true)
					for _, rk := range vi.required {
						h.If(List(Id("_"), Id("ok")).Op(":=").Id("m").Index(Lit(rk)), Op("!").Id("ok")).Block(Id("match").Op("=").Lit(false))
					}
					h.If(Id("match")).Block(
						If(Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")).Op("!=").Nil()).Block(Return(Qual("errors", "New").Call(Lit("invalid variant payload")))),
						Id("u").Dot(vi.fieldName).Op("=").Op("&").Id("v"),
						Return(Nil()),
					)
				})
			}
		}
		// fallback: try decode sequentially
		for _, vi := range variants {
			g.Block(
				Var().Id("v").Id(vi.typeName),
				If(Qual("encoding/json", "Unmarshal").Call(Id("b"), Op("&").Id("v")).Op("==").Nil()).Block(
					Id("u").Dot(vi.fieldName).Op("=").Op("&").Id("v"),
					Return(Nil()),
				),
			)
		}
		g.Return(Nil())
	})
	// Marshal
	f.Func().Params(Id("u").Id(name)).Id("MarshalJSON").Params().Params(Index().Byte(), Error()).BlockFunc(func(g *Group) {
		for _, vi := range variants {
			g.If(Id("u").Dot(vi.fieldName).Op("!=").Nil()).BlockFunc(func(gg *Group) {
				// Null-only variant encodes to JSON null
				if vi.isNull {
					gg.Return(Qual("encoding/json", "Marshal").Call(Nil()))
				} else {
					// Marshal variant to map for discriminant injection and shaping
					gg.Var().Id("m").Map(String()).Any()
					gg.List(Id("_b"), Id("_e")).Op(":=").Qual("encoding/json", "Marshal").Call(Op("*").Id("u").Dot(vi.fieldName))
					gg.If(Id("_e").Op("!=").Nil()).Block(Return(Index().Byte().Values(), Id("_e")))
					gg.If(Qual("encoding/json", "Unmarshal").Call(Id("_b"), Op("&").Id("m")).Op("!=").Nil()).Block(Return(Index().Byte().Values(), Qual("errors", "New").Call(Lit("invalid variant payload"))))
					// Inject const discriminants
					if len(vi.constPairs) > 0 {
						for _, kv := range vi.constPairs {
							gg.Id("m").Index(Lit(kv[0])).Op("=").Lit(kv[1])
						}
					}
					// Special shaping for ContentBlock variants to preserve exact wire JSON
					if name == "ContentBlock" {
						switch vi.discValue {
						case "text":
							gg.Block(
								Var().Id("nm").Map(String()).Any(),
								Id("nm").Op("=").Make(Map(String()).Any()),
								Id("nm").Index(Lit("type")).Op("=").Lit("text"),
								Id("nm").Index(Lit("text")).Op("=").Id("m").Index(Lit("text")),
								Return(Qual("encoding/json", "Marshal").Call(Id("nm"))),
							)
						case "image":
							gg.Block(
								Var().Id("nm").Map(String()).Any(),
								Id("nm").Op("=").Make(Map(String()).Any()),
								Id("nm").Index(Lit("type")).Op("=").Lit("image"),
								Id("nm").Index(Lit("data")).Op("=").Id("m").Index(Lit("data")),
								Id("nm").Index(Lit("mimeType")).Op("=").Id("m").Index(Lit("mimeType")),
								// Only include uri if present; do not emit null
								If(List(Id("_v"), Id("_ok")).Op(":=").Id("m").Index(Lit("uri")), Id("_ok")).Block(
									Id("nm").Index(Lit("uri")).Op("=").Id("_v"),
								),
								Return(Qual("encoding/json", "Marshal").Call(Id("nm"))),
							)
						case "audio":
							gg.Block(
								Var().Id("nm").Map(String()).Any(),
								Id("nm").Op("=").Make(Map(String()).Any()),
								Id("nm").Index(Lit("type")).Op("=").Lit("audio"),
								Id("nm").Index(Lit("data")).Op("=").Id("m").Index(Lit("data")),
								Id("nm").Index(Lit("mimeType")).Op("=").Id("m").Index(Lit("mimeType")),
								Return(Qual("encoding/json", "Marshal").Call(Id("nm"))),
							)
						case "resource_link":
							gg.BlockFunc(func(b *Group) {
								b.Var().Id("nm").Map(String()).Any()
								b.Id("nm").Op("=").Make(Map(String()).Any())
								b.Id("nm").Index(Lit("type")).Op("=").Lit("resource_link")
								b.Id("nm").Index(Lit("name")).Op("=").Id("m").Index(Lit("name"))
								b.Id("nm").Index(Lit("uri")).Op("=").Id("m").Index(Lit("uri"))
								// Only include optional keys if present
								b.If(List(Id("v1"), Id("ok1")).Op(":=").Id("m").Index(Lit("description")), Id("ok1")).Block(
									Id("nm").Index(Lit("description")).Op("=").Id("v1"),
								)
								b.If(List(Id("v2"), Id("ok2")).Op(":=").Id("m").Index(Lit("mimeType")), Id("ok2")).Block(
									Id("nm").Index(Lit("mimeType")).Op("=").Id("v2"),
								)
								b.If(List(Id("v3"), Id("ok3")).Op(":=").Id("m").Index(Lit("size")), Id("ok3")).Block(
									Id("nm").Index(Lit("size")).Op("=").Id("v3"),
								)
								b.If(List(Id("v4"), Id("ok4")).Op(":=").Id("m").Index(Lit("title")), Id("ok4")).Block(
									Id("nm").Index(Lit("title")).Op("=").Id("v4"),
								)
								b.Return(Qual("encoding/json", "Marshal").Call(Id("nm")))
							})
						case "resource":
							gg.Block(
								Var().Id("nm").Map(String()).Any(),
								Id("nm").Op("=").Make(Map(String()).Any()),
								Id("nm").Index(Lit("type")).Op("=").Lit("resource"),
								Id("nm").Index(Lit("resource")).Op("=").Id("m").Index(Lit("resource")),
								Return(Qual("encoding/json", "Marshal").Call(Id("nm"))),
							)
						}
					}
					// default: remarshal possibly with injected discriminant
					if name != "ContentBlock" {
						gg.Return(Qual("encoding/json", "Marshal").Call(Id("m")))
					}
				}
			})
		}
		g.Return(Index().Byte().Values(), Nil())
	})
	f.Line()

	// Generic validator for oneOf unions: exactly one variant must be set
	if exactlyOne {
		f.Func().Params(Id("u").Op("*").Id(name)).Id("Validate").Params().Params(Error()).BlockFunc(func(g *Group) {
			g.Var().Id("count").Int()
			for _, vi := range variants {
				g.If(Id("u").Dot(vi.fieldName).Op("!=").Nil()).Block(Id("count").Op("++"))
			}
			g.If(Id("count").Op("!=").Lit(1)).Block(
				Return(Qual("errors", "New").Call(Lit(name + " must have exactly one variant set"))),
			)
			g.Return(Nil())
		})
		f.Line()
	}
}
