package emit

import (
	"bytes"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/zed-industries/agent-client-protocol/go/cmd/generate/internal/ir"
	"github.com/zed-industries/agent-client-protocol/go/cmd/generate/internal/load"
)

// WriteDispatchJen emits agent_gen.go and client_gen.go with handlers and wrappers.
func WriteDispatchJen(outDir string, schema *load.Schema, meta *load.Meta) error {
	groups := ir.BuildMethodGroups(schema, meta)

	// Agent handler + outbound wrappers
	fAgent := NewFile("acp")
	fAgent.HeaderComment("Code generated by acp-go-generator; DO NOT EDIT.")

	amKeys := make([]string, 0, len(meta.AgentMethods))
	for k := range meta.AgentMethods {
		amKeys = append(amKeys, k)
	}
	sort.Strings(amKeys)
	switchCases := []Code{}
	for _, k := range amKeys {
		wire := meta.AgentMethods[k]
		mi := groups["agent|"+wire]
		if mi == nil {
			continue
		}
		caseBody := []Code{}
		if mi.Notif != "" {
			caseBody = append(caseBody, jUnmarshalValidate(mi.Notif)...)
			// Special-case: session/cancel should also cancel any in-flight prompt ctx for the session.
			if mi.Method == "session/cancel" {
				caseBody = append(caseBody,
					// cancel active prompt context if present
					Id("a").Dot("mu").Dot("Lock").Call(),
					If(List(Id("cn"), Id("ok")).Op(":=").Id("a").Dot("sessionCancels").Index(Id("string").Call(Id("p").Dot("SessionId"))), Id("ok")).Block(
						Id("cn").Call(),
						Id("delete").Call(Id("a").Dot("sessionCancels"), Id("string").Call(Id("p").Dot("SessionId"))),
					),
					Id("a").Dot("mu").Dot("Unlock").Call(),
				)
			}
			callName := ir.DispatchMethodNameForNotification(k, mi.Notif)
			caseBody = append(caseBody, jCallNotification("a.agent", callName)...)
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			caseBody = append(caseBody, jUnmarshalValidate(mi.Req)...)
			methodName := strings.TrimSuffix(mi.Req, "Request")
			pre, recv := jAgentAssert(mi.Binding)
			if pre != nil {
				caseBody = append(caseBody, pre...)
			}
			if mi.Method == "session/prompt" {
				// Derive a cancellable context per session prompt.
				caseBody = append(caseBody,
					Var().Id("reqCtx").Qual("context", "Context"), Var().Id("cancel").Qual("context", "CancelFunc"),
					List(Id("reqCtx"), Id("cancel")).Op("=").Qual("context", "WithCancel").Call(Id("ctx")),
					Id("a").Dot("mu").Dot("Lock").Call(),
					If(List(Id("prev"), Id("ok")).Op(":=").Id("a").Dot("sessionCancels").Index(Id("string").Call(Id("p").Dot("SessionId"))), Id("ok")).Block(Id("prev").Call()),
					Id("a").Dot("sessionCancels").Index(Id("string").Call(Id("p").Dot("SessionId"))).Op("=").Id("cancel"),
					Id("a").Dot("mu").Dot("Unlock").Call(),
				)
				// Call agent.Prompt(reqCtx, p)
				caseBody = append(caseBody,
					List(Id("resp"), Id("err")).Op(":=").Id(recv).Dot(methodName).Call(Id("reqCtx"), Id("p")),
					// cleanup entry after return
					Id("a").Dot("mu").Dot("Lock").Call(),
					Id("delete").Call(Id("a").Dot("sessionCancels"), Id("string").Call(Id("p").Dot("SessionId"))),
					Id("a").Dot("mu").Dot("Unlock").Call(),
					If(Id("err").Op("!=").Nil()).Block(jRetToReqErr()),
					Return(Id("resp"), Nil()),
				)
			} else if ir.IsNullResponse(schema.Defs[respName]) {
				caseBody = append(caseBody, jCallRequestNoResp(recv, methodName)...)
			} else {
				caseBody = append(caseBody, jCallRequestWithResp(recv, methodName)...)
			}
		}
		if len(caseBody) > 0 {
			switchCases = append(switchCases, Case(Id("AgentMethod"+toExportedConst(k))).Block(caseBody...))
		}
	}
	switchCases = append(switchCases, Default().Block(Return(Nil(), Id("NewMethodNotFound").Call(Id("method")))))
	fAgent.Func().Params(Id("a").Op("*").Id("AgentSideConnection")).Id("handle").Params(
		Id("ctx").Qual("context", "Context"), Id("method").String(), Id("params").Qual("encoding/json", "RawMessage")).
		Params(Any(), Op("*").Id("RequestError")).
		Block(Switch(Id("method")).Block(switchCases...))

	// Agent outbound wrappers (agent -> client)
	agentConst := map[string]string{}
	for k, v := range meta.AgentMethods {
		agentConst[v] = "AgentMethod" + toExportedConst(k)
	}
	clientConst := map[string]string{}
	for k, v := range meta.ClientMethods {
		clientConst[v] = "ClientMethod" + toExportedConst(k)
	}

	cmKeys2 := make([]string, 0, len(meta.ClientMethods))
	for k := range meta.ClientMethods {
		cmKeys2 = append(cmKeys2, k)
	}
	sort.Strings(cmKeys2)
	for _, k := range cmKeys2 {
		wire := meta.ClientMethods[k]
		mi := groups["client|"+wire]
		if mi == nil {
			continue
		}
		constName := clientConst[mi.Method]
		if constName == "" {
			continue
		}
		if mi.Notif != "" {
			name := strings.TrimSuffix(mi.Notif, "Notification")
			switch mi.Method {
			case "session/update":
				name = "SessionUpdate"
			case "session/cancel":
				name = "Cancel"
			}
			fAgent.Func().Params(Id("c").Op("*").Id("AgentSideConnection")).Id(name).Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Notif)).Error().
				Block(Return(Id("c").Dot("conn").Dot("SendNotification").Call(Id("ctx"), Id(constName), Id("params"))))
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			if ir.IsNullResponse(schema.Defs[respName]) {
				fAgent.Func().Params(Id("c").Op("*").Id("AgentSideConnection")).Id(strings.TrimSuffix(mi.Req, "Request")).
					Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Req)).Error().
					Block(Return(Id("c").Dot("conn").Dot("SendRequestNoResult").Call(Id("ctx"), Id(constName), Id("params"))))
			} else {
				fAgent.Func().Params(Id("c").Op("*").Id("AgentSideConnection")).Id(strings.TrimSuffix(mi.Req, "Request")).
					Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Req)).Params(Id(respName), Error()).
					Block(
						List(Id("resp"), Id("err")).Op(":=").Id("SendRequest").Types(Id(respName)).Call(Id("c").Dot("conn"), Id("ctx"), Id(constName), Id("params")),
						Return(Id("resp"), Id("err")),
					)
			}
		}
	}
	var bufA bytes.Buffer
	if err := fAgent.Render(&bufA); err != nil {
		return err
	}
	if err := os.WriteFile(filepath.Join(outDir, "agent_gen.go"), bufA.Bytes(), 0o644); err != nil {
		return err
	}

	// Client handler + outbound wrappers
	fClient := NewFile("acp")
	fClient.HeaderComment("Code generated by acp-go-generator; DO NOT EDIT.")
	cmKeys := make([]string, 0, len(meta.ClientMethods))
	for k := range meta.ClientMethods {
		cmKeys = append(cmKeys, k)
	}
	sort.Strings(cmKeys)
	cCases := []Code{}
	for _, k := range cmKeys {
		wire := meta.ClientMethods[k]
		mi := groups["client|"+wire]
		if mi == nil {
			continue
		}
		body := []Code{}
		if mi.Notif != "" {
			body = append(body, jUnmarshalValidate(mi.Notif)...)
			pre, recv := jClientAssert(mi.Binding)
			if pre != nil {
				body = append(body, pre...)
			}
			callName := ir.DispatchMethodNameForNotification(k, mi.Notif)
			body = append(body, jCallNotification(recv, callName)...)
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			body = append(body, jUnmarshalValidate(mi.Req)...)
			methodName := strings.TrimSuffix(mi.Req, "Request")
			pre, recv := jClientAssert(mi.Binding)
			if pre != nil {
				body = append(body, pre...)
			}
			if ir.IsNullResponse(schema.Defs[respName]) {
				body = append(body, jCallRequestNoResp(recv, methodName)...)
			} else {
				body = append(body, jCallRequestWithResp(recv, methodName)...)
			}
		}
		if len(body) > 0 {
			cCases = append(cCases, Case(Id("ClientMethod"+toExportedConst(k))).Block(body...))
		}
	}
	cCases = append(cCases, Default().Block(Return(Nil(), Id("NewMethodNotFound").Call(Id("method")))))
	fClient.Func().Params(Id("c").Op("*").Id("ClientSideConnection")).Id("handle").Params(
		Id("ctx").Qual("context", "Context"), Id("method").String(), Id("params").Qual("encoding/json", "RawMessage")).
		Params(Any(), Op("*").Id("RequestError")).
		Block(Switch(Id("method")).Block(cCases...))

	// Client outbound wrappers (client -> agent)
	amKeys2 := make([]string, 0, len(meta.AgentMethods))
	for k := range meta.AgentMethods {
		amKeys2 = append(amKeys2, k)
	}
	sort.Strings(amKeys2)
	for _, k := range amKeys2 {
		wire := meta.AgentMethods[k]
		mi := groups["agent|"+wire]
		if mi == nil {
			continue
		}
		constName := agentConst[mi.Method]
		if constName == "" {
			continue
		}
		if mi.Notif != "" {
			name := strings.TrimSuffix(mi.Notif, "Notification")
			switch mi.Method {
			case "session/update":
				name = "SessionUpdate"
			case "session/cancel":
				name = "Cancel"
			}
			fClient.Func().Params(Id("c").Op("*").Id("ClientSideConnection")).Id(name).Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Notif)).Error().
				Block(Return(Id("c").Dot("conn").Dot("SendNotification").Call(Id("ctx"), Id(constName), Id("params"))))
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			if ir.IsNullResponse(schema.Defs[respName]) {
				fClient.Func().Params(Id("c").Op("*").Id("ClientSideConnection")).Id(strings.TrimSuffix(mi.Req, "Request")).
					Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Req)).Error().
					Block(Return(Id("c").Dot("conn").Dot("SendRequestNoResult").Call(Id("ctx"), Id(constName), Id("params"))))
			} else {
				// Special-case: session/prompt â€” if ctx was canceled, send session/cancel best-effort.
				if mi.Method == "session/prompt" {
					fClient.Func().Params(Id("c").Op("*").Id("ClientSideConnection")).Id(strings.TrimSuffix(mi.Req, "Request")).
						Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Req)).Params(Id(respName), Error()).
						Block(
							List(Id("resp"), Id("err")).Op(":=").Id("SendRequest").Types(Id(respName)).Call(Id("c").Dot("conn"), Id("ctx"), Id(constName), Id("params")),
							If(Id("err").Op("!=").Nil()).Block(
								If(Id("ctx").Dot("Err").Call().Op("!=").Nil()).Block(
									Id("_ ").Op("=").Id("c").Dot("Cancel").Call(Qual("context", "Background").Call(), Id("CancelNotification").Values(Dict{Id("SessionId"): Id("params").Dot("SessionId")})),
								),
							),
							Return(Id("resp"), Id("err")),
						)
				} else {
					fClient.Func().Params(Id("c").Op("*").Id("ClientSideConnection")).Id(strings.TrimSuffix(mi.Req, "Request")).
						Params(Id("ctx").Qual("context", "Context"), Id("params").Id(mi.Req)).Params(Id(respName), Error()).
						Block(
							List(Id("resp"), Id("err")).Op(":=").Id("SendRequest").Types(Id(respName)).Call(Id("c").Dot("conn"), Id("ctx"), Id(constName), Id("params")),
							Return(Id("resp"), Id("err")),
						)
				}
			}
		}
	}
	var bufC bytes.Buffer
	if err := fClient.Render(&bufC); err != nil {
		return err
	}
	if err := os.WriteFile(filepath.Join(outDir, "client_gen.go"), bufC.Bytes(), 0o644); err != nil {
		return err
	}

	return nil
}
