package emit

import (
	"bytes"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/zed-industries/agent-client-protocol/go/cmd/generate/internal/ir"
	"github.com/zed-industries/agent-client-protocol/go/cmd/generate/internal/load"
)

// WriteDispatchJen emits agent_gen.go and client_gen.go with handlers and wrappers.
func WriteDispatchJen(outDir string, schema *load.Schema, meta *load.Meta) error {
	groups := ir.BuildMethodGroups(schema, meta)

	// Agent handler + outbound wrappers
	fAgent := NewFile("acp")
	fAgent.HeaderComment("Code generated by acp-go-generator; DO NOT EDIT.")

	amKeys := make([]string, 0, len(meta.AgentMethods))
	for k := range meta.AgentMethods {
		amKeys = append(amKeys, k)
	}
	sort.Strings(amKeys)
	switchCases := []Code{}
	for _, k := range amKeys {
		wire := meta.AgentMethods[k]
		mi := groups["agent|"+wire]
		if mi == nil {
			continue
		}
		caseBody := []Code{}
		if mi.Notif != "" {
			caseBody = append(caseBody, jUnmarshalValidate(mi.Notif)...)
			callName := ir.DispatchMethodNameForNotification(k, mi.Notif)
			caseBody = append(caseBody, jCallNotification("a.agent", callName)...)
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			caseBody = append(caseBody, jUnmarshalValidate(mi.Req)...)
			methodName := strings.TrimSuffix(mi.Req, "Request")
			pre, recv := jAgentAssert(mi.Binding)
			if pre != nil {
				caseBody = append(caseBody, pre...)
			}
			if ir.IsNullResponse(schema.Defs[respName]) {
				caseBody = append(caseBody, jCallRequestNoResp(recv, methodName)...)
			} else {
				caseBody = append(caseBody, jCallRequestWithResp(recv, methodName, respName)...)
			}
		}
		if len(caseBody) > 0 {
			switchCases = append(switchCases, Case(Id("AgentMethod"+toExportedConst(k))).Block(caseBody...))
		}
	}
	switchCases = append(switchCases, Default().Block(Return(Nil(), Id("NewMethodNotFound").Call(Id("method")))))
	fAgent.Func().Params(Id("a").Op("*").Id("AgentSideConnection")).Id("handle").Params(
		Id("method").String(), Id("params").Qual("encoding/json", "RawMessage")).
		Params(Any(), Op("*").Id("RequestError")).
		Block(Switch(Id("method")).Block(switchCases...))

	// Agent outbound wrappers (agent -> client)
	agentConst := map[string]string{}
	for k, v := range meta.AgentMethods {
		agentConst[v] = "AgentMethod" + toExportedConst(k)
	}
	clientConst := map[string]string{}
	for k, v := range meta.ClientMethods {
		clientConst[v] = "ClientMethod" + toExportedConst(k)
	}

	cmKeys2 := make([]string, 0, len(meta.ClientMethods))
	for k := range meta.ClientMethods {
		cmKeys2 = append(cmKeys2, k)
	}
	sort.Strings(cmKeys2)
	for _, k := range cmKeys2 {
		wire := meta.ClientMethods[k]
		mi := groups["client|"+wire]
		if mi == nil {
			continue
		}
		constName := clientConst[mi.Method]
		if constName == "" {
			continue
		}
		if mi.Notif != "" {
			name := strings.TrimSuffix(mi.Notif, "Notification")
			switch mi.Method {
			case "session/update":
				name = "SessionUpdate"
			case "session/cancel":
				name = "Cancel"
			}
			fAgent.Func().Params(Id("c").Op("*").Id("AgentSideConnection")).Id(name).Params(Id("params").Id(mi.Notif)).Error().
				Block(Return(Id("c").Dot("conn").Dot("SendNotification").Call(Id(constName), Id("params"))))
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			if ir.IsNullResponse(schema.Defs[respName]) {
				fAgent.Func().Params(Id("c").Op("*").Id("AgentSideConnection")).Id(strings.TrimSuffix(mi.Req, "Request")).
					Params(Id("params").Id(mi.Req)).Error().
					Block(Return(Id("c").Dot("conn").Dot("SendRequestNoResult").Call(Id(constName), Id("params"))))
			} else {
				fAgent.Func().Params(Id("c").Op("*").Id("AgentSideConnection")).Id(strings.TrimSuffix(mi.Req, "Request")).
					Params(Id("params").Id(mi.Req)).Params(Id(respName), Error()).
					Block(
						List(Id("resp"), Id("err")).Op(":=").Id("SendRequest").Types(Id(respName)).Call(Id("c").Dot("conn"), Id(constName), Id("params")),
						Return(Id("resp"), Id("err")),
					)
			}
		}
	}
	var bufA bytes.Buffer
	if err := fAgent.Render(&bufA); err != nil {
		return err
	}
	if err := os.WriteFile(filepath.Join(outDir, "agent_gen.go"), bufA.Bytes(), 0o644); err != nil {
		return err
	}

	// Client handler + outbound wrappers
	fClient := NewFile("acp")
	fClient.HeaderComment("Code generated by acp-go-generator; DO NOT EDIT.")
	cmKeys := make([]string, 0, len(meta.ClientMethods))
	for k := range meta.ClientMethods {
		cmKeys = append(cmKeys, k)
	}
	sort.Strings(cmKeys)
	cCases := []Code{}
	for _, k := range cmKeys {
		wire := meta.ClientMethods[k]
		mi := groups["client|"+wire]
		if mi == nil {
			continue
		}
		body := []Code{}
		if mi.Notif != "" {
			body = append(body, jUnmarshalValidate(mi.Notif)...)
			pre, recv := jClientAssert(mi.Binding)
			if pre != nil {
				body = append(body, pre...)
			}
			callName := ir.DispatchMethodNameForNotification(k, mi.Notif)
			body = append(body, jCallNotification(recv, callName)...)
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			body = append(body, jUnmarshalValidate(mi.Req)...)
			methodName := strings.TrimSuffix(mi.Req, "Request")
			pre, recv := jClientAssert(mi.Binding)
			if pre != nil {
				body = append(body, pre...)
			}
			if ir.IsNullResponse(schema.Defs[respName]) {
				body = append(body, jCallRequestNoResp(recv, methodName)...)
			} else {
				body = append(body, jCallRequestWithResp(recv, methodName, respName)...)
			}
		}
		if len(body) > 0 {
			cCases = append(cCases, Case(Id("ClientMethod"+toExportedConst(k))).Block(body...))
		}
	}
	cCases = append(cCases, Default().Block(Return(Nil(), Id("NewMethodNotFound").Call(Id("method")))))
	fClient.Func().Params(Id("c").Op("*").Id("ClientSideConnection")).Id("handle").Params(
		Id("method").String(), Id("params").Qual("encoding/json", "RawMessage")).
		Params(Any(), Op("*").Id("RequestError")).
		Block(Switch(Id("method")).Block(cCases...))

	// Client outbound wrappers (client -> agent)
	amKeys2 := make([]string, 0, len(meta.AgentMethods))
	for k := range meta.AgentMethods {
		amKeys2 = append(amKeys2, k)
	}
	sort.Strings(amKeys2)
	for _, k := range amKeys2 {
		wire := meta.AgentMethods[k]
		mi := groups["agent|"+wire]
		if mi == nil {
			continue
		}
		constName := agentConst[mi.Method]
		if constName == "" {
			continue
		}
		if mi.Notif != "" {
			name := strings.TrimSuffix(mi.Notif, "Notification")
			switch mi.Method {
			case "session/update":
				name = "SessionUpdate"
			case "session/cancel":
				name = "Cancel"
			}
			fClient.Func().Params(Id("c").Op("*").Id("ClientSideConnection")).Id(name).Params(Id("params").Id(mi.Notif)).Error().
				Block(Return(Id("c").Dot("conn").Dot("SendNotification").Call(Id(constName), Id("params"))))
		} else if mi.Req != "" {
			respName := strings.TrimSuffix(mi.Req, "Request") + "Response"
			if ir.IsNullResponse(schema.Defs[respName]) {
				fClient.Func().Params(Id("c").Op("*").Id("ClientSideConnection")).Id(strings.TrimSuffix(mi.Req, "Request")).
					Params(Id("params").Id(mi.Req)).Error().
					Block(Return(Id("c").Dot("conn").Dot("SendRequestNoResult").Call(Id(constName), Id("params"))))
			} else {
				fClient.Func().Params(Id("c").Op("*").Id("ClientSideConnection")).Id(strings.TrimSuffix(mi.Req, "Request")).
					Params(Id("params").Id(mi.Req)).Params(Id(respName), Error()).
					Block(
						List(Id("resp"), Id("err")).Op(":=").Id("SendRequest").Types(Id(respName)).Call(Id("c").Dot("conn"), Id(constName), Id("params")),
						Return(Id("resp"), Id("err")),
					)
			}
		}
	}
	var bufC bytes.Buffer
	if err := fClient.Render(&bufC); err != nil {
		return err
	}
	if err := os.WriteFile(filepath.Join(outDir, "client_gen.go"), bufC.Bytes(), 0o644); err != nil {
		return err
	}

	return nil
}
