package emit

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/zed-industries/agent-client-protocol/go/cmd/generate/internal/load"
	"github.com/zed-industries/agent-client-protocol/go/cmd/generate/internal/util"
)

// WriteHelpersJen emits go/helpers_gen.go with small constructor helpers
// for common union variants and a Ptr generic helper.
func WriteHelpersJen(outDir string, schema *load.Schema, _ *load.Meta) error {
	f := NewFile("acp")
	f.HeaderComment("Code generated by acp-go-generator; DO NOT EDIT.")

	// Schema-driven generic helpers: New<Union><Variant>(required fields only)
	// Iterate definitions deterministically
	keys := make([]string, 0, len(schema.Defs))
	for k := range schema.Defs {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, name := range keys {
		def := schema.Defs[name]
		if def == nil || def.DocsIgnore || len(def.OneOf) == 0 {
			continue
		}
		// Skip string-const unions
		if isStringConstUnion(def) {
			continue
		}
		// Skip generating New... helpers for unions that have stable, static helpers
		// implemented in go/helpers.go.
		switch name {
		case "ContentBlock", "ToolCallContent", "SessionUpdate":
			continue
		}
		// Build variant info similarly to types emitter
		type vinfo struct {
			fieldName string
			typeName  string
			discKey   string
			discValue string
			required  []string
			props     map[string]*load.Definition
		}
		discKey := ""
		for _, v := range def.OneOf {
			if v == nil {
				continue
			}
			for k, pd := range v.Properties {
				if pd != nil && pd.Const != nil {
					discKey = k
					break
				}
			}
			if discKey != "" {
				break
			}
		}
		variants := []vinfo{}
		for idx, v := range def.OneOf {
			if v == nil {
				continue
			}
			// compute type name per types emitter
			tname := v.Title
			if tname == "" {
				if v.Ref != "" && strings.HasPrefix(v.Ref, "#/$defs/") {
					tname = v.Ref[len("#/$defs/"):]
				} else {
					if discKey != "" {
						if pd := v.Properties[discKey]; pd != nil && pd.Const != nil {
							s := fmt.Sprint(pd.Const)
							tname = name + util.ToExportedField(s)
						}
					}
					if tname == "" {
						tname = name + fmt.Sprintf("Variant%d", idx+1)
					}
				}
			}
			fieldName := tname
			dv := ""
			if discKey != "" {
				if pd := v.Properties[discKey]; pd != nil && pd.Const != nil {
					s := fmt.Sprint(pd.Const)
					fieldName = util.ToExportedField(s)
					dv = s
				}
			}
			// collect required
			req := make([]string, len(v.Required))
			copy(req, v.Required)
			variants = append(variants, vinfo{fieldName: fieldName, typeName: tname, discKey: discKey, discValue: dv, required: req, props: v.Properties})
		}
		// Emit helper per variant: func New<Union><FieldName>(...) <Union>
		for _, vi := range variants {
			// params: all required props except const discriminator
			params := []Code{}
			assigns := Dict{}
			for _, rk := range vi.required {
				if rk == vi.discKey {
					continue
				}
				pd := vi.props[rk]
				if pd == nil {
					continue
				}
				// build param using lower-cased name
				pname := rk
				// field id for struct literal
				field := util.ToExportedField(rk)
				params = append(params, Id(pname).Add(jenTypeFor(pd)))
				assigns[Id(field)] = Id(pname)
			}
			// include const discriminant if present and field exists on struct
			if vi.discKey != "" && vi.discValue != "" {
				assigns[Id(util.ToExportedField(vi.discKey))] = Lit(vi.discValue)
			}
			// Construct variant literal and wrap
			f.Comment(fmt.Sprintf("New%s%s constructs a %s using the '%s' variant.", name, vi.fieldName, name, vi.discValue))
			f.Func().Id("New" + name + vi.fieldName).Params(params...).Id(name).Block(
				Return(
					Id(name).Values(Dict{
						Id(vi.fieldName): Op("&").Id(vi.typeName).Values(assigns),
					}),
				),
			)
			f.Line()
		}
	}

	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		return err
	}
	return os.WriteFile(filepath.Join(outDir, "helpers_gen.go"), buf.Bytes(), 0o644)
}
