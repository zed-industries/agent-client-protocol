// Code generated by acp-go-generator; DO NOT EDIT.

package acp

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
)

// Capabilities supported by the agent.  Advertised during initialization to inform the client about available features and content types.  See protocol docs: [Agent Capabilities](https://agentclientprotocol.com/protocol/initialization#agent-capabilities)
type AgentCapabilities struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Whether the agent supports 'session/load'.
	//
	// Defaults to false if unset.
	LoadSession bool `json:"loadSession,omitempty"`
	// MCP capabilities supported by the agent.
	//
	// Defaults to {"http":false,"sse":false} if unset.
	McpCapabilities McpCapabilities `json:"mcpCapabilities,omitempty"`
	// Prompt capabilities supported by the agent.
	//
	// Defaults to {"audio":false,"embeddedContext":false,"image":false} if unset.
	PromptCapabilities PromptCapabilities `json:"promptCapabilities,omitempty"`
}

func (v AgentCapabilities) MarshalJSON() ([]byte, error) {
	type Alias AgentCapabilities
	var a Alias
	a = Alias(v)
	return json.Marshal(a)
}

func (v *AgentCapabilities) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	type Alias AgentCapabilities
	var a Alias
	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}
	{
		_rm, _ok := m["loadSession"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.LoadSession)
		}
	}
	{
		_rm, _ok := m["mcpCapabilities"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("{\"http\":false,\"sse\":false}"), &a.McpCapabilities)
		}
	}
	{
		_rm, _ok := m["promptCapabilities"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("{\"audio\":false,\"embeddedContext\":false,\"image\":false}"), &a.PromptCapabilities)
		}
	}
	*v = AgentCapabilities(a)
	return nil
}

// All possible notifications that an agent can send to a client.  This enum is used internally for routing RPC notifications. You typically won't need to use this directly - use the notification methods on the ['Client'] trait instead.  Notifications do not expect a response.
type AgentNotification struct {
	SessionNotification *SessionNotification `json:"-"`
}

func (u *AgentNotification) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v SessionNotification
		if json.Unmarshal(b, &v) == nil {
			u.SessionNotification = &v
			return nil
		}
	}
	return nil
}
func (u AgentNotification) MarshalJSON() ([]byte, error) {
	if u.SessionNotification != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.SessionNotification)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// All possible requests that an agent can send to a client.  This enum is used internally for routing RPC requests. You typically won't need to use this directly - instead, use the methods on the ['Client'] trait.  This enum encompasses all method calls from agent to client.
type AgentRequest struct {
	WriteTextFileRequest       *WriteTextFileRequest       `json:"-"`
	ReadTextFileRequest        *ReadTextFileRequest        `json:"-"`
	RequestPermissionRequest   *RequestPermissionRequest   `json:"-"`
	CreateTerminalRequest      *CreateTerminalRequest      `json:"-"`
	TerminalOutputRequest      *TerminalOutputRequest      `json:"-"`
	ReleaseTerminalRequest     *ReleaseTerminalRequest     `json:"-"`
	WaitForTerminalExitRequest *WaitForTerminalExitRequest `json:"-"`
	KillTerminalCommandRequest *KillTerminalCommandRequest `json:"-"`
}

func (u *AgentRequest) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v WriteTextFileRequest
		if json.Unmarshal(b, &v) == nil {
			u.WriteTextFileRequest = &v
			return nil
		}
	}
	{
		var v ReadTextFileRequest
		if json.Unmarshal(b, &v) == nil {
			u.ReadTextFileRequest = &v
			return nil
		}
	}
	{
		var v RequestPermissionRequest
		if json.Unmarshal(b, &v) == nil {
			u.RequestPermissionRequest = &v
			return nil
		}
	}
	{
		var v CreateTerminalRequest
		if json.Unmarshal(b, &v) == nil {
			u.CreateTerminalRequest = &v
			return nil
		}
	}
	{
		var v TerminalOutputRequest
		if json.Unmarshal(b, &v) == nil {
			u.TerminalOutputRequest = &v
			return nil
		}
	}
	{
		var v ReleaseTerminalRequest
		if json.Unmarshal(b, &v) == nil {
			u.ReleaseTerminalRequest = &v
			return nil
		}
	}
	{
		var v WaitForTerminalExitRequest
		if json.Unmarshal(b, &v) == nil {
			u.WaitForTerminalExitRequest = &v
			return nil
		}
	}
	{
		var v KillTerminalCommandRequest
		if json.Unmarshal(b, &v) == nil {
			u.KillTerminalCommandRequest = &v
			return nil
		}
	}
	return nil
}
func (u AgentRequest) MarshalJSON() ([]byte, error) {
	if u.WriteTextFileRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.WriteTextFileRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.ReadTextFileRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ReadTextFileRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.RequestPermissionRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.RequestPermissionRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.CreateTerminalRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.CreateTerminalRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.TerminalOutputRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.TerminalOutputRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.ReleaseTerminalRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ReleaseTerminalRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.WaitForTerminalExitRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.WaitForTerminalExitRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.KillTerminalCommandRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.KillTerminalCommandRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// All possible responses that an agent can send to a client.  This enum is used internally for routing RPC responses. You typically won't need to use this directly - the responses are handled automatically by the connection.  These are responses to the corresponding 'ClientRequest' variants.
type AgentResponse struct {
	InitializeResponse      *InitializeResponse      `json:"-"`
	AuthenticateResponse    *AuthenticateResponse    `json:"-"`
	NewSessionResponse      *NewSessionResponse      `json:"-"`
	LoadSessionResponse     *LoadSessionResponse     `json:"-"`
	SetSessionModeResponse  *SetSessionModeResponse  `json:"-"`
	PromptResponse          *PromptResponse          `json:"-"`
	SetSessionModelResponse *SetSessionModelResponse `json:"-"`
}

func (u *AgentResponse) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v InitializeResponse
		if json.Unmarshal(b, &v) == nil {
			u.InitializeResponse = &v
			return nil
		}
	}
	{
		var v AuthenticateResponse
		if json.Unmarshal(b, &v) == nil {
			u.AuthenticateResponse = &v
			return nil
		}
	}
	{
		var v NewSessionResponse
		if json.Unmarshal(b, &v) == nil {
			u.NewSessionResponse = &v
			return nil
		}
	}
	{
		var v LoadSessionResponse
		if json.Unmarshal(b, &v) == nil {
			u.LoadSessionResponse = &v
			return nil
		}
	}
	{
		var v SetSessionModeResponse
		if json.Unmarshal(b, &v) == nil {
			u.SetSessionModeResponse = &v
			return nil
		}
	}
	{
		var v PromptResponse
		if json.Unmarshal(b, &v) == nil {
			u.PromptResponse = &v
			return nil
		}
	}
	{
		var v SetSessionModelResponse
		if json.Unmarshal(b, &v) == nil {
			u.SetSessionModelResponse = &v
			return nil
		}
	}
	return nil
}
func (u AgentResponse) MarshalJSON() ([]byte, error) {
	if u.InitializeResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.InitializeResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.AuthenticateResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.AuthenticateResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.NewSessionResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.NewSessionResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.LoadSessionResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.LoadSessionResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.SetSessionModeResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.SetSessionModeResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.PromptResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.PromptResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.SetSessionModelResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.SetSessionModelResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// Optional annotations for the client. The client can use annotations to inform how objects are used or displayed
type Annotations struct {
	// Extension point for implementations
	Meta         any      `json:"_meta,omitempty"`
	Audience     []Role   `json:"audience,omitempty"`
	LastModified *string  `json:"lastModified,omitempty"`
	Priority     *float64 `json:"priority,omitempty"`
}

// Audio provided to or from an LLM.
type AudioContent struct {
	// Extension point for implementations
	Meta        any          `json:"_meta,omitempty"`
	Annotations *Annotations `json:"annotations,omitempty"`
	Data        string       `json:"data"`
	MimeType    string       `json:"mimeType"`
}

// Describes an available authentication method.
type AuthMethod struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Optional description providing more details about this authentication method.
	Description *string `json:"description,omitempty"`
	// Unique identifier for this authentication method.
	Id AuthMethodId `json:"id"`
	// Human-readable name of the authentication method.
	Name string `json:"name"`
}

// Unique identifier for an authentication method.
type AuthMethodId string

// Request parameters for the authenticate method.  Specifies which authentication method to use.
type AuthenticateRequest struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The ID of the authentication method to use. Must be one of the methods advertised in the initialize response.
	MethodId AuthMethodId `json:"methodId"`
}

func (v *AuthenticateRequest) Validate() error {
	return nil
}

// Response to authenticate method
type AuthenticateResponse struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
}

func (v *AuthenticateResponse) Validate() error {
	return nil
}

// Information about a command.
type AvailableCommand struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Human-readable description of what the command does.
	Description string `json:"description"`
	// Input for the command if required
	Input *AvailableCommandInput `json:"input,omitempty"`
	// Command name (e.g., 'create_plan', 'research_codebase').
	Name string `json:"name"`
}

// The input specification for a command.
// All text that was typed after the command name is provided as input.
type UnstructuredCommandInput struct {
	// A hint to display when the input hasn't been provided yet
	Hint string `json:"hint"`
}

type AvailableCommandInput struct {
	UnstructuredCommandInput *UnstructuredCommandInput `json:"-"`
}

func (u *AvailableCommandInput) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v UnstructuredCommandInput
		var match bool = true
		if _, ok := m["hint"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.UnstructuredCommandInput = &v
			return nil
		}
	}
	{
		var v UnstructuredCommandInput
		if json.Unmarshal(b, &v) == nil {
			u.UnstructuredCommandInput = &v
			return nil
		}
	}
	return nil
}
func (u AvailableCommandInput) MarshalJSON() ([]byte, error) {
	if u.UnstructuredCommandInput != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.UnstructuredCommandInput)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// Binary resource contents.
type BlobResourceContents struct {
	// Extension point for implementations
	Meta     any     `json:"_meta,omitempty"`
	Blob     string  `json:"blob"`
	MimeType *string `json:"mimeType,omitempty"`
	Uri      string  `json:"uri"`
}

// Notification to cancel ongoing operations for a session.  See protocol docs: [Cancellation](https://agentclientprotocol.com/protocol/prompt-turn#cancellation)
type CancelNotification struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The ID of the session to cancel operations for.
	SessionId SessionId `json:"sessionId"`
}

func (v *CancelNotification) Validate() error {
	return nil
}

// Capabilities supported by the client.  Advertised during initialization to inform the agent about available features and methods.  See protocol docs: [Client Capabilities](https://agentclientprotocol.com/protocol/initialization#client-capabilities)
type ClientCapabilities struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// File system capabilities supported by the client. Determines which file operations the agent can request.
	//
	// Defaults to {"readTextFile":false,"writeTextFile":false} if unset.
	Fs FileSystemCapability `json:"fs,omitempty"`
	// Whether the Client support all 'terminal/*' methods.
	//
	// Defaults to false if unset.
	Terminal bool `json:"terminal,omitempty"`
}

func (v ClientCapabilities) MarshalJSON() ([]byte, error) {
	type Alias ClientCapabilities
	var a Alias
	a = Alias(v)
	return json.Marshal(a)
}

func (v *ClientCapabilities) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	type Alias ClientCapabilities
	var a Alias
	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}
	{
		_rm, _ok := m["fs"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("{\"readTextFile\":false,\"writeTextFile\":false}"), &a.Fs)
		}
	}
	{
		_rm, _ok := m["terminal"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.Terminal)
		}
	}
	*v = ClientCapabilities(a)
	return nil
}

// All possible notifications that a client can send to an agent.  This enum is used internally for routing RPC notifications. You typically won't need to use this directly - use the notification methods on the ['Agent'] trait instead.  Notifications do not expect a response.
type ClientNotification struct {
	CancelNotification *CancelNotification `json:"-"`
}

func (u *ClientNotification) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v CancelNotification
		if json.Unmarshal(b, &v) == nil {
			u.CancelNotification = &v
			return nil
		}
	}
	return nil
}
func (u ClientNotification) MarshalJSON() ([]byte, error) {
	if u.CancelNotification != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.CancelNotification)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// All possible requests that a client can send to an agent.  This enum is used internally for routing RPC requests. You typically won't need to use this directly - instead, use the methods on the ['Agent'] trait.  This enum encompasses all method calls from client to agent.
type ClientRequest struct {
	InitializeRequest      *InitializeRequest      `json:"-"`
	AuthenticateRequest    *AuthenticateRequest    `json:"-"`
	NewSessionRequest      *NewSessionRequest      `json:"-"`
	LoadSessionRequest     *LoadSessionRequest     `json:"-"`
	SetSessionModeRequest  *SetSessionModeRequest  `json:"-"`
	PromptRequest          *PromptRequest          `json:"-"`
	SetSessionModelRequest *SetSessionModelRequest `json:"-"`
}

func (u *ClientRequest) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v InitializeRequest
		if json.Unmarshal(b, &v) == nil {
			u.InitializeRequest = &v
			return nil
		}
	}
	{
		var v AuthenticateRequest
		if json.Unmarshal(b, &v) == nil {
			u.AuthenticateRequest = &v
			return nil
		}
	}
	{
		var v NewSessionRequest
		if json.Unmarshal(b, &v) == nil {
			u.NewSessionRequest = &v
			return nil
		}
	}
	{
		var v LoadSessionRequest
		if json.Unmarshal(b, &v) == nil {
			u.LoadSessionRequest = &v
			return nil
		}
	}
	{
		var v SetSessionModeRequest
		if json.Unmarshal(b, &v) == nil {
			u.SetSessionModeRequest = &v
			return nil
		}
	}
	{
		var v PromptRequest
		if json.Unmarshal(b, &v) == nil {
			u.PromptRequest = &v
			return nil
		}
	}
	{
		var v SetSessionModelRequest
		if json.Unmarshal(b, &v) == nil {
			u.SetSessionModelRequest = &v
			return nil
		}
	}
	return nil
}
func (u ClientRequest) MarshalJSON() ([]byte, error) {
	if u.InitializeRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.InitializeRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.AuthenticateRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.AuthenticateRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.NewSessionRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.NewSessionRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.LoadSessionRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.LoadSessionRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.SetSessionModeRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.SetSessionModeRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.PromptRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.PromptRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.SetSessionModelRequest != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.SetSessionModelRequest)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// All possible responses that a client can send to an agent.  This enum is used internally for routing RPC responses. You typically won't need to use this directly - the responses are handled automatically by the connection.  These are responses to the corresponding 'AgentRequest' variants.
type ClientResponse struct {
	WriteTextFileResponse       *WriteTextFileResponse       `json:"-"`
	ReadTextFileResponse        *ReadTextFileResponse        `json:"-"`
	RequestPermissionResponse   *RequestPermissionResponse   `json:"-"`
	CreateTerminalResponse      *CreateTerminalResponse      `json:"-"`
	TerminalOutputResponse      *TerminalOutputResponse      `json:"-"`
	ReleaseTerminalResponse     *ReleaseTerminalResponse     `json:"-"`
	WaitForTerminalExitResponse *WaitForTerminalExitResponse `json:"-"`
	KillTerminalCommandResponse *KillTerminalCommandResponse `json:"-"`
}

func (u *ClientResponse) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var v WriteTextFileResponse
		if json.Unmarshal(b, &v) == nil {
			u.WriteTextFileResponse = &v
			return nil
		}
	}
	{
		var v ReadTextFileResponse
		if json.Unmarshal(b, &v) == nil {
			u.ReadTextFileResponse = &v
			return nil
		}
	}
	{
		var v RequestPermissionResponse
		if json.Unmarshal(b, &v) == nil {
			u.RequestPermissionResponse = &v
			return nil
		}
	}
	{
		var v CreateTerminalResponse
		if json.Unmarshal(b, &v) == nil {
			u.CreateTerminalResponse = &v
			return nil
		}
	}
	{
		var v TerminalOutputResponse
		if json.Unmarshal(b, &v) == nil {
			u.TerminalOutputResponse = &v
			return nil
		}
	}
	{
		var v ReleaseTerminalResponse
		if json.Unmarshal(b, &v) == nil {
			u.ReleaseTerminalResponse = &v
			return nil
		}
	}
	{
		var v WaitForTerminalExitResponse
		if json.Unmarshal(b, &v) == nil {
			u.WaitForTerminalExitResponse = &v
			return nil
		}
	}
	{
		var v KillTerminalCommandResponse
		if json.Unmarshal(b, &v) == nil {
			u.KillTerminalCommandResponse = &v
			return nil
		}
	}
	return nil
}
func (u ClientResponse) MarshalJSON() ([]byte, error) {
	if u.WriteTextFileResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.WriteTextFileResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.ReadTextFileResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ReadTextFileResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.RequestPermissionResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.RequestPermissionResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.CreateTerminalResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.CreateTerminalResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.TerminalOutputResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.TerminalOutputResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.ReleaseTerminalResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ReleaseTerminalResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.WaitForTerminalExitResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.WaitForTerminalExitResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.KillTerminalCommandResponse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.KillTerminalCommandResponse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// Content blocks represent displayable information in the Agent Client Protocol.  They provide a structured way to handle various types of user-facing content—whether it's text from language models, images for analysis, or embedded resources for context.  Content blocks appear in: - User prompts sent via 'session/prompt' - Language model output streamed through 'session/update' notifications - Progress updates and results from tool calls  This structure is compatible with the Model Context Protocol (MCP), enabling agents to seamlessly forward content from MCP tool outputs without transformation.  See protocol docs: [Content](https://agentclientprotocol.com/protocol/content)
// Plain text content  All agents MUST support text content blocks in prompts.
type ContentBlockText struct {
	// Extension point for implementations
	Meta        any          `json:"_meta,omitempty"`
	Annotations *Annotations `json:"annotations,omitempty"`
	Text        string       `json:"text"`
	Type        string       `json:"type"`
}

// Images for visual context or analysis.  Requires the 'image' prompt capability when included in prompts.
type ContentBlockImage struct {
	// Extension point for implementations
	Meta        any          `json:"_meta,omitempty"`
	Annotations *Annotations `json:"annotations,omitempty"`
	Data        string       `json:"data"`
	MimeType    string       `json:"mimeType"`
	Type        string       `json:"type"`
	Uri         *string      `json:"uri,omitempty"`
}

// Audio data for transcription or analysis.  Requires the 'audio' prompt capability when included in prompts.
type ContentBlockAudio struct {
	// Extension point for implementations
	Meta        any          `json:"_meta,omitempty"`
	Annotations *Annotations `json:"annotations,omitempty"`
	Data        string       `json:"data"`
	MimeType    string       `json:"mimeType"`
	Type        string       `json:"type"`
}

// References to resources that the agent can access.  All agents MUST support resource links in prompts.
type ContentBlockResourceLink struct {
	// Extension point for implementations
	Meta        any          `json:"_meta,omitempty"`
	Annotations *Annotations `json:"annotations,omitempty"`
	Description *string      `json:"description,omitempty"`
	MimeType    *string      `json:"mimeType,omitempty"`
	Name        string       `json:"name"`
	Size        *int         `json:"size,omitempty"`
	Title       *string      `json:"title,omitempty"`
	Type        string       `json:"type"`
	Uri         string       `json:"uri"`
}

// Complete resource contents embedded directly in the message.  Preferred for including context as it avoids extra round-trips.  Requires the 'embeddedContext' prompt capability when included in prompts.
type ContentBlockResource struct {
	// Extension point for implementations
	Meta        any                      `json:"_meta,omitempty"`
	Annotations *Annotations             `json:"annotations,omitempty"`
	Resource    EmbeddedResourceResource `json:"resource"`
	Type        string                   `json:"type"`
}

type ContentBlock struct {
	Text         *ContentBlockText         `json:"-"`
	Image        *ContentBlockImage        `json:"-"`
	Audio        *ContentBlockAudio        `json:"-"`
	ResourceLink *ContentBlockResourceLink `json:"-"`
	Resource     *ContentBlockResource     `json:"-"`
}

func (u *ContentBlock) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var disc string
		if v, ok := m["type"]; ok {
			json.Unmarshal(v, &disc)
		}
		switch disc {
		case "text":
			var v ContentBlockText
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Text = &v
			return nil
		case "image":
			var v ContentBlockImage
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Image = &v
			return nil
		case "audio":
			var v ContentBlockAudio
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Audio = &v
			return nil
		case "resource_link":
			var v ContentBlockResourceLink
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.ResourceLink = &v
			return nil
		case "resource":
			var v ContentBlockResource
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Resource = &v
			return nil
		}
	}
	{
		var v ContentBlockText
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["text"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Text = &v
			return nil
		}
	}
	{
		var v ContentBlockImage
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["data"]; !ok {
			match = false
		}
		if _, ok := m["mimeType"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Image = &v
			return nil
		}
	}
	{
		var v ContentBlockAudio
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["data"]; !ok {
			match = false
		}
		if _, ok := m["mimeType"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Audio = &v
			return nil
		}
	}
	{
		var v ContentBlockResourceLink
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["name"]; !ok {
			match = false
		}
		if _, ok := m["uri"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.ResourceLink = &v
			return nil
		}
	}
	{
		var v ContentBlockResource
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["resource"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Resource = &v
			return nil
		}
	}
	{
		var v ContentBlockText
		if json.Unmarshal(b, &v) == nil {
			u.Text = &v
			return nil
		}
	}
	{
		var v ContentBlockImage
		if json.Unmarshal(b, &v) == nil {
			u.Image = &v
			return nil
		}
	}
	{
		var v ContentBlockAudio
		if json.Unmarshal(b, &v) == nil {
			u.Audio = &v
			return nil
		}
	}
	{
		var v ContentBlockResourceLink
		if json.Unmarshal(b, &v) == nil {
			u.ResourceLink = &v
			return nil
		}
	}
	{
		var v ContentBlockResource
		if json.Unmarshal(b, &v) == nil {
			u.Resource = &v
			return nil
		}
	}
	return nil
}
func (u ContentBlock) MarshalJSON() ([]byte, error) {
	if u.Text != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Text)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "text"
		{
			var nm map[string]any
			nm = make(map[string]any)
			nm["type"] = "text"
			nm["text"] = m["text"]
			return json.Marshal(nm)
		}
	}
	if u.Image != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Image)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "image"
		{
			var nm map[string]any
			nm = make(map[string]any)
			nm["type"] = "image"
			nm["data"] = m["data"]
			nm["mimeType"] = m["mimeType"]
			if _v, _ok := m["uri"]; _ok {
				nm["uri"] = _v
			}
			return json.Marshal(nm)
		}
	}
	if u.Audio != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Audio)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "audio"
		{
			var nm map[string]any
			nm = make(map[string]any)
			nm["type"] = "audio"
			nm["data"] = m["data"]
			nm["mimeType"] = m["mimeType"]
			return json.Marshal(nm)
		}
	}
	if u.ResourceLink != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ResourceLink)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "resource_link"
		{
			var nm map[string]any
			nm = make(map[string]any)
			nm["type"] = "resource_link"
			nm["name"] = m["name"]
			nm["uri"] = m["uri"]
			if v1, ok1 := m["description"]; ok1 {
				nm["description"] = v1
			}
			if v2, ok2 := m["mimeType"]; ok2 {
				nm["mimeType"] = v2
			}
			if v3, ok3 := m["size"]; ok3 {
				nm["size"] = v3
			}
			if v4, ok4 := m["title"]; ok4 {
				nm["title"] = v4
			}
			return json.Marshal(nm)
		}
	}
	if u.Resource != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Resource)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "resource"
		{
			var nm map[string]any
			nm = make(map[string]any)
			nm["type"] = "resource"
			nm["resource"] = m["resource"]
			return json.Marshal(nm)
		}
	}
	return []byte{}, nil
}

func (u *ContentBlock) Validate() error {
	var count int
	if u.Text != nil {
		count++
	}
	if u.Image != nil {
		count++
	}
	if u.Audio != nil {
		count++
	}
	if u.ResourceLink != nil {
		count++
	}
	if u.Resource != nil {
		count++
	}
	if count != 1 {
		return errors.New("ContentBlock must have exactly one variant set")
	}
	return nil
}

// Request to create a new terminal and execute a command.
type CreateTerminalRequest struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Array of command arguments.
	Args []string `json:"args,omitempty"`
	// The command to execute.
	Command string `json:"command"`
	// Working directory for the command (absolute path).
	Cwd *string `json:"cwd,omitempty"`
	// Environment variables for the command.
	Env []EnvVariable `json:"env,omitempty"`
	// Maximum number of output bytes to retain.  When the limit is exceeded, the Client truncates from the beginning of the output to stay within the limit.  The Client MUST ensure truncation happens at a character boundary to maintain valid string output, even if this means the retained output is slightly less than the specified limit.
	OutputByteLimit *int `json:"outputByteLimit,omitempty"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
}

func (v *CreateTerminalRequest) Validate() error {
	if v.Command == "" {
		return fmt.Errorf("command is required")
	}
	return nil
}

// Response containing the ID of the created terminal.
type CreateTerminalResponse struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The unique identifier for the created terminal.
	TerminalId string `json:"terminalId"`
}

func (v *CreateTerminalResponse) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

// The contents of a resource, embedded into a prompt or tool call result.
type EmbeddedResource struct {
	// Extension point for implementations
	Meta        any                      `json:"_meta,omitempty"`
	Annotations *Annotations             `json:"annotations,omitempty"`
	Resource    EmbeddedResourceResource `json:"resource"`
}

// Resource content that can be embedded in a message.
type EmbeddedResourceResource struct {
	TextResourceContents *TextResourceContents `json:"-"`
	BlobResourceContents *BlobResourceContents `json:"-"`
}

func (u *EmbeddedResourceResource) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	if _, ok := m["text"]; ok {
		var v TextResourceContents
		if json.Unmarshal(b, &v) != nil {
			return errors.New("invalid variant payload")
		}
		u.TextResourceContents = &v
		return nil
	}
	if _, ok := m["blob"]; ok {
		var v BlobResourceContents
		if json.Unmarshal(b, &v) != nil {
			return errors.New("invalid variant payload")
		}
		u.BlobResourceContents = &v
		return nil
	}
	{
		var v TextResourceContents
		if json.Unmarshal(b, &v) == nil {
			u.TextResourceContents = &v
			return nil
		}
	}
	{
		var v BlobResourceContents
		if json.Unmarshal(b, &v) == nil {
			u.BlobResourceContents = &v
			return nil
		}
	}
	return nil
}
func (u EmbeddedResourceResource) MarshalJSON() ([]byte, error) {
	if u.TextResourceContents != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.TextResourceContents)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	if u.BlobResourceContents != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.BlobResourceContents)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// An environment variable to set when launching an MCP server.
type EnvVariable struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The name of the environment variable.
	Name string `json:"name"`
	// The value to set for the environment variable.
	Value string `json:"value"`
}

// File system capabilities that a client may support.  See protocol docs: [FileSystem](https://agentclientprotocol.com/protocol/initialization#filesystem)
type FileSystemCapability struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Whether the Client supports 'fs/read_text_file' requests.
	//
	// Defaults to false if unset.
	ReadTextFile bool `json:"readTextFile,omitempty"`
	// Whether the Client supports 'fs/write_text_file' requests.
	//
	// Defaults to false if unset.
	WriteTextFile bool `json:"writeTextFile,omitempty"`
}

func (v FileSystemCapability) MarshalJSON() ([]byte, error) {
	type Alias FileSystemCapability
	var a Alias
	a = Alias(v)
	return json.Marshal(a)
}

func (v *FileSystemCapability) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	type Alias FileSystemCapability
	var a Alias
	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}
	{
		_rm, _ok := m["readTextFile"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.ReadTextFile)
		}
	}
	{
		_rm, _ok := m["writeTextFile"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.WriteTextFile)
		}
	}
	*v = FileSystemCapability(a)
	return nil
}

// An HTTP header to set when making requests to the MCP server.
type HttpHeader struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The name of the HTTP header.
	Name string `json:"name"`
	// The value to set for the HTTP header.
	Value string `json:"value"`
}

// An image provided to or from an LLM.
type ImageContent struct {
	// Extension point for implementations
	Meta        any          `json:"_meta,omitempty"`
	Annotations *Annotations `json:"annotations,omitempty"`
	Data        string       `json:"data"`
	MimeType    string       `json:"mimeType"`
	Uri         *string      `json:"uri,omitempty"`
}

// Request parameters for the initialize method.  Sent by the client to establish connection and negotiate capabilities.  See protocol docs: [Initialization](https://agentclientprotocol.com/protocol/initialization)
type InitializeRequest struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Capabilities supported by the client.
	//
	// Defaults to {"fs":{"readTextFile":false,"writeTextFile":false},"terminal":false} if unset.
	ClientCapabilities ClientCapabilities `json:"clientCapabilities,omitempty"`
	// The latest protocol version supported by the client.
	ProtocolVersion ProtocolVersion `json:"protocolVersion"`
}

func (v InitializeRequest) MarshalJSON() ([]byte, error) {
	type Alias InitializeRequest
	var a Alias
	a = Alias(v)
	return json.Marshal(a)
}

func (v *InitializeRequest) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	type Alias InitializeRequest
	var a Alias
	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}
	{
		_rm, _ok := m["clientCapabilities"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("{\"fs\":{\"readTextFile\":false,\"writeTextFile\":false},\"terminal\":false}"), &a.ClientCapabilities)
		}
	}
	*v = InitializeRequest(a)
	return nil
}

func (v *InitializeRequest) Validate() error {
	return nil
}

// Response from the initialize method.  Contains the negotiated protocol version and agent capabilities.  See protocol docs: [Initialization](https://agentclientprotocol.com/protocol/initialization)
type InitializeResponse struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Capabilities supported by the agent.
	//
	// Defaults to {"loadSession":false,"mcpCapabilities":{"http":false,"sse":false},"promptCapabilities":{"audio":false,"embeddedContext":false,"image":false}} if unset.
	AgentCapabilities AgentCapabilities `json:"agentCapabilities,omitempty"`
	// Authentication methods supported by the agent.
	//
	// Defaults to [] if unset.
	AuthMethods []AuthMethod `json:"authMethods"`
	// The protocol version the client specified if supported by the agent, or the latest protocol version supported by the agent.  The client should disconnect, if it doesn't support this version.
	ProtocolVersion ProtocolVersion `json:"protocolVersion"`
}

func (v InitializeResponse) MarshalJSON() ([]byte, error) {
	type Alias InitializeResponse
	var a Alias
	a = Alias(v)
	if a.AuthMethods == nil {
		json.Unmarshal([]byte("[]"), &a.AuthMethods)
	}
	return json.Marshal(a)
}

func (v *InitializeResponse) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	type Alias InitializeResponse
	var a Alias
	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}
	{
		_rm, _ok := m["agentCapabilities"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("{\"loadSession\":false,\"mcpCapabilities\":{\"http\":false,\"sse\":false},\"promptCapabilities\":{\"audio\":false,\"embeddedContext\":false,\"image\":false}}"), &a.AgentCapabilities)
		}
	}
	{
		_rm, _ok := m["authMethods"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("[]"), &a.AuthMethods)
		}
	}
	*v = InitializeResponse(a)
	return nil
}

func (v *InitializeResponse) Validate() error {
	return nil
}

// Request to kill a terminal command without releasing the terminal.
type KillTerminalCommandRequest struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
	// The ID of the terminal to kill.
	TerminalId string `json:"terminalId"`
}

func (v *KillTerminalCommandRequest) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

// Response to terminal/kill command method
type KillTerminalCommandResponse struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
}

func (v *KillTerminalCommandResponse) Validate() error {
	return nil
}

// Request parameters for loading an existing session.  Only available if the Agent supports the 'loadSession' capability.  See protocol docs: [Loading Sessions](https://agentclientprotocol.com/protocol/session-setup#loading-sessions)
type LoadSessionRequest struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The working directory for this session.
	Cwd string `json:"cwd"`
	// List of MCP servers to connect to for this session.
	McpServers []McpServer `json:"mcpServers"`
	// The ID of the session to load.
	SessionId SessionId `json:"sessionId"`
}

func (v *LoadSessionRequest) Validate() error {
	if v.Cwd == "" {
		return fmt.Errorf("cwd is required")
	}
	if v.McpServers == nil {
		return fmt.Errorf("mcpServers is required")
	}
	return nil
}

// Response from loading an existing session.
type LoadSessionResponse struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// **UNSTABLE**  This capability is not part of the spec yet, and may be removed or changed at any point.  Initial model state if supported by the Agent
	Models *SessionModelState `json:"models,omitempty"`
	// Initial mode state if supported by the Agent  See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
	Modes *SessionModeState `json:"modes,omitempty"`
}

func (v *LoadSessionResponse) Validate() error {
	return nil
}

// MCP capabilities supported by the agent
type McpCapabilities struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Agent supports ['McpServer::Http'].
	//
	// Defaults to false if unset.
	Http bool `json:"http,omitempty"`
	// Agent supports ['McpServer::Sse'].
	//
	// Defaults to false if unset.
	Sse bool `json:"sse,omitempty"`
}

func (v McpCapabilities) MarshalJSON() ([]byte, error) {
	type Alias McpCapabilities
	var a Alias
	a = Alias(v)
	return json.Marshal(a)
}

func (v *McpCapabilities) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	type Alias McpCapabilities
	var a Alias
	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}
	{
		_rm, _ok := m["http"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.Http)
		}
	}
	{
		_rm, _ok := m["sse"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.Sse)
		}
	}
	*v = McpCapabilities(a)
	return nil
}

// Configuration for connecting to an MCP (Model Context Protocol) server.  MCP servers provide tools and context that the agent can use when processing prompts.  See protocol docs: [MCP Servers](https://agentclientprotocol.com/protocol/session-setup#mcp-servers)
// HTTP transport configuration  Only available when the Agent capabilities indicate 'mcp_capabilities.http' is 'true'.
type McpServerHttp struct {
	// HTTP headers to set when making requests to the MCP server.
	Headers []HttpHeader `json:"headers"`
	// Human-readable name identifying this MCP server.
	Name string `json:"name"`
	Type string `json:"type"`
	// URL to the MCP server.
	Url string `json:"url"`
}

// SSE transport configuration  Only available when the Agent capabilities indicate 'mcp_capabilities.sse' is 'true'.
type McpServerSse struct {
	// HTTP headers to set when making requests to the MCP server.
	Headers []HttpHeader `json:"headers"`
	// Human-readable name identifying this MCP server.
	Name string `json:"name"`
	Type string `json:"type"`
	// URL to the MCP server.
	Url string `json:"url"`
}

// Stdio transport configuration  All Agents MUST support this transport.
type Stdio struct {
	// Command-line arguments to pass to the MCP server.
	Args []string `json:"args"`
	// Path to the MCP server executable.
	Command string `json:"command"`
	// Environment variables to set when launching the MCP server.
	Env []EnvVariable `json:"env"`
	// Human-readable name identifying this MCP server.
	Name string `json:"name"`
}

type McpServer struct {
	Http  *McpServerHttp `json:"-"`
	Sse   *McpServerSse  `json:"-"`
	Stdio *Stdio         `json:"-"`
}

func (u *McpServer) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var disc string
		if v, ok := m["type"]; ok {
			json.Unmarshal(v, &disc)
		}
		switch disc {
		case "http":
			var v McpServerHttp
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Http = &v
			return nil
		case "sse":
			var v McpServerSse
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Sse = &v
			return nil
		}
	}
	{
		var v McpServerHttp
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["name"]; !ok {
			match = false
		}
		if _, ok := m["url"]; !ok {
			match = false
		}
		if _, ok := m["headers"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Http = &v
			return nil
		}
	}
	{
		var v McpServerSse
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["name"]; !ok {
			match = false
		}
		if _, ok := m["url"]; !ok {
			match = false
		}
		if _, ok := m["headers"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Sse = &v
			return nil
		}
	}
	{
		var v Stdio
		var match bool = true
		if _, ok := m["name"]; !ok {
			match = false
		}
		if _, ok := m["command"]; !ok {
			match = false
		}
		if _, ok := m["args"]; !ok {
			match = false
		}
		if _, ok := m["env"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Stdio = &v
			return nil
		}
	}
	{
		var v McpServerHttp
		if json.Unmarshal(b, &v) == nil {
			u.Http = &v
			return nil
		}
	}
	{
		var v McpServerSse
		if json.Unmarshal(b, &v) == nil {
			u.Sse = &v
			return nil
		}
	}
	{
		var v Stdio
		if json.Unmarshal(b, &v) == nil {
			u.Stdio = &v
			return nil
		}
	}
	return nil
}
func (u McpServer) MarshalJSON() ([]byte, error) {
	if u.Http != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Http)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "http"
		return json.Marshal(m)
	}
	if u.Sse != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Sse)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "sse"
		return json.Marshal(m)
	}
	if u.Stdio != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Stdio)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		return json.Marshal(m)
	}
	return []byte{}, nil
}

// **UNSTABLE**  This capability is not part of the spec yet, and may be removed or changed at any point.  A unique identifier for a model.
type ModelId string

// **UNSTABLE**  This capability is not part of the spec yet, and may be removed or changed at any point.  Information about a selectable model.
type ModelInfo struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Optional description of the model.
	Description *string `json:"description,omitempty"`
	// Unique identifier for the model.
	ModelId ModelId `json:"modelId"`
	// Human-readable name of the model.
	Name string `json:"name"`
}

// Request parameters for creating a new session.  See protocol docs: [Creating a Session](https://agentclientprotocol.com/protocol/session-setup#creating-a-session)
type NewSessionRequest struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The working directory for this session. Must be an absolute path.
	Cwd string `json:"cwd"`
	// List of MCP (Model Context Protocol) servers the agent should connect to.
	McpServers []McpServer `json:"mcpServers"`
}

func (v *NewSessionRequest) Validate() error {
	if v.Cwd == "" {
		return fmt.Errorf("cwd is required")
	}
	if v.McpServers == nil {
		return fmt.Errorf("mcpServers is required")
	}
	return nil
}

// Response from creating a new session.  See protocol docs: [Creating a Session](https://agentclientprotocol.com/protocol/session-setup#creating-a-session)
type NewSessionResponse struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// **UNSTABLE**  This capability is not part of the spec yet, and may be removed or changed at any point.  Initial model state if supported by the Agent
	Models *SessionModelState `json:"models,omitempty"`
	// Initial mode state if supported by the Agent  See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
	Modes *SessionModeState `json:"modes,omitempty"`
	// Unique identifier for the created session.  Used in all subsequent requests for this conversation.
	SessionId SessionId `json:"sessionId"`
}

func (v *NewSessionResponse) Validate() error {
	return nil
}

// An option presented to the user when requesting permission.
type PermissionOption struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Hint about the nature of this permission option.
	Kind PermissionOptionKind `json:"kind"`
	// Human-readable label to display to the user.
	Name string `json:"name"`
	// Unique identifier for this permission option.
	OptionId PermissionOptionId `json:"optionId"`
}

// Unique identifier for a permission option.
type PermissionOptionId string

// The type of permission option being presented to the user.  Helps clients choose appropriate icons and UI treatment.
type PermissionOptionKind string

const (
	PermissionOptionKindAllowOnce    PermissionOptionKind = "allow_once"
	PermissionOptionKindAllowAlways  PermissionOptionKind = "allow_always"
	PermissionOptionKindRejectOnce   PermissionOptionKind = "reject_once"
	PermissionOptionKindRejectAlways PermissionOptionKind = "reject_always"
)

// An execution plan for accomplishing complex tasks.  Plans consist of multiple entries representing individual tasks or goals. Agents report plans to clients to provide visibility into their execution strategy. Plans can evolve during execution as the agent discovers new requirements or completes tasks.  See protocol docs: [Agent Plan](https://agentclientprotocol.com/protocol/agent-plan)
type Plan struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The list of tasks to be accomplished.  When updating a plan, the agent must send a complete list of all entries with their current status. The client replaces the entire plan with each update.
	Entries []PlanEntry `json:"entries"`
}

// A single entry in the execution plan.  Represents a task or goal that the assistant intends to accomplish as part of fulfilling the user's request. See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
type PlanEntry struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Human-readable description of what this task aims to accomplish.
	Content string `json:"content"`
	// The relative importance of this task. Used to indicate which tasks are most critical to the overall goal.
	Priority PlanEntryPriority `json:"priority"`
	// Current execution status of this task.
	Status PlanEntryStatus `json:"status"`
}

// Priority levels for plan entries.  Used to indicate the relative importance or urgency of different tasks in the execution plan. See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
type PlanEntryPriority string

const (
	PlanEntryPriorityHigh   PlanEntryPriority = "high"
	PlanEntryPriorityMedium PlanEntryPriority = "medium"
	PlanEntryPriorityLow    PlanEntryPriority = "low"
)

// Status of a plan entry in the execution flow.  Tracks the lifecycle of each task from planning through completion. See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
type PlanEntryStatus string

const (
	PlanEntryStatusPending    PlanEntryStatus = "pending"
	PlanEntryStatusInProgress PlanEntryStatus = "in_progress"
	PlanEntryStatusCompleted  PlanEntryStatus = "completed"
)

// Prompt capabilities supported by the agent in 'session/prompt' requests.  Baseline agent functionality requires support for ['ContentBlock::Text'] and ['ContentBlock::ResourceLink'] in prompt requests.  Other variants must be explicitly opted in to. Capabilities for different types of content in prompt requests.  Indicates which content types beyond the baseline (text and resource links) the agent can process.  See protocol docs: [Prompt Capabilities](https://agentclientprotocol.com/protocol/initialization#prompt-capabilities)
type PromptCapabilities struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Agent supports ['ContentBlock::Audio'].
	//
	// Defaults to false if unset.
	Audio bool `json:"audio,omitempty"`
	// Agent supports embedded context in 'session/prompt' requests.  When enabled, the Client is allowed to include ['ContentBlock::Resource'] in prompt requests for pieces of context that are referenced in the message.
	//
	// Defaults to false if unset.
	EmbeddedContext bool `json:"embeddedContext,omitempty"`
	// Agent supports ['ContentBlock::Image'].
	//
	// Defaults to false if unset.
	Image bool `json:"image,omitempty"`
}

func (v PromptCapabilities) MarshalJSON() ([]byte, error) {
	type Alias PromptCapabilities
	var a Alias
	a = Alias(v)
	return json.Marshal(a)
}

func (v *PromptCapabilities) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	type Alias PromptCapabilities
	var a Alias
	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}
	{
		_rm, _ok := m["audio"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.Audio)
		}
	}
	{
		_rm, _ok := m["embeddedContext"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.EmbeddedContext)
		}
	}
	{
		_rm, _ok := m["image"]
		if !_ok || (string(_rm) == "null") {
			json.Unmarshal([]byte("false"), &a.Image)
		}
	}
	*v = PromptCapabilities(a)
	return nil
}

// Request parameters for sending a user prompt to the agent.  Contains the user's message and any additional context.  See protocol docs: [User Message](https://agentclientprotocol.com/protocol/prompt-turn#1-user-message)
type PromptRequest struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The blocks of content that compose the user's message.  As a baseline, the Agent MUST support ['ContentBlock::Text'] and ['ContentBlock::ResourceLink'], while other variants are optionally enabled via ['PromptCapabilities'].  The Client MUST adapt its interface according to ['PromptCapabilities'].  The client MAY include referenced pieces of context as either ['ContentBlock::Resource'] or ['ContentBlock::ResourceLink'].  When available, ['ContentBlock::Resource'] is preferred as it avoids extra round-trips and allows the message to include pieces of context from sources the agent may not have access to.
	Prompt []ContentBlock `json:"prompt"`
	// The ID of the session to send this user message to
	SessionId SessionId `json:"sessionId"`
}

func (v *PromptRequest) Validate() error {
	if v.Prompt == nil {
		return fmt.Errorf("prompt is required")
	}
	return nil
}

// Response from processing a user prompt.  See protocol docs: [Check for Completion](https://agentclientprotocol.com/protocol/prompt-turn#4-check-for-completion)
type PromptResponse struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Indicates why the agent stopped processing the turn.
	StopReason StopReason `json:"stopReason"`
}

func (v *PromptResponse) Validate() error {
	return nil
}

// Protocol version identifier.  This version is only bumped for breaking changes. Non-breaking changes should be introduced via capabilities.
type ProtocolVersion int

// Request to read content from a text file.  Only available if the client supports the 'fs.readTextFile' capability.
type ReadTextFileRequest struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Maximum number of lines to read.
	Limit *int `json:"limit,omitempty"`
	// Line number to start reading from (1-based).
	Line *int `json:"line,omitempty"`
	// Absolute path to the file to read.
	Path string `json:"path"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
}

func (v *ReadTextFileRequest) Validate() error {
	if v.Path == "" {
		return fmt.Errorf("path is required")
	}
	return nil
}

// Response containing the contents of a text file.
type ReadTextFileResponse struct {
	// Extension point for implementations
	Meta    any    `json:"_meta,omitempty"`
	Content string `json:"content"`
}

func (v *ReadTextFileResponse) Validate() error {
	if v.Content == "" {
		return fmt.Errorf("content is required")
	}
	return nil
}

// Request to release a terminal and free its resources.
type ReleaseTerminalRequest struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
	// The ID of the terminal to release.
	TerminalId string `json:"terminalId"`
}

func (v *ReleaseTerminalRequest) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

// Response to terminal/release method
type ReleaseTerminalResponse struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
}

func (v *ReleaseTerminalResponse) Validate() error {
	return nil
}

// The outcome of a permission request.
// The prompt turn was cancelled before the user responded.  When a client sends a 'session/cancel' notification to cancel an ongoing prompt turn, it MUST respond to all pending 'session/request_permission' requests with this 'Cancelled' outcome.  See protocol docs: [Cancellation](https://agentclientprotocol.com/protocol/prompt-turn#cancellation)
type RequestPermissionOutcomeCancelled struct {
	Outcome string `json:"outcome"`
}

// The user selected one of the provided options.
type RequestPermissionOutcomeSelected struct {
	// The ID of the option the user selected.
	OptionId PermissionOptionId `json:"optionId"`
	Outcome  string             `json:"outcome"`
}

type RequestPermissionOutcome struct {
	Cancelled *RequestPermissionOutcomeCancelled `json:"-"`
	Selected  *RequestPermissionOutcomeSelected  `json:"-"`
}

func (u *RequestPermissionOutcome) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var disc string
		if v, ok := m["outcome"]; ok {
			json.Unmarshal(v, &disc)
		}
		switch disc {
		case "cancelled":
			var v RequestPermissionOutcomeCancelled
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Cancelled = &v
			return nil
		case "selected":
			var v RequestPermissionOutcomeSelected
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Selected = &v
			return nil
		}
	}
	{
		var v RequestPermissionOutcomeCancelled
		var match bool = true
		if _, ok := m["outcome"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Cancelled = &v
			return nil
		}
	}
	{
		var v RequestPermissionOutcomeSelected
		var match bool = true
		if _, ok := m["outcome"]; !ok {
			match = false
		}
		if _, ok := m["optionId"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Selected = &v
			return nil
		}
	}
	{
		var v RequestPermissionOutcomeCancelled
		if json.Unmarshal(b, &v) == nil {
			u.Cancelled = &v
			return nil
		}
	}
	{
		var v RequestPermissionOutcomeSelected
		if json.Unmarshal(b, &v) == nil {
			u.Selected = &v
			return nil
		}
	}
	return nil
}
func (u RequestPermissionOutcome) MarshalJSON() ([]byte, error) {
	if u.Cancelled != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Cancelled)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["outcome"] = "cancelled"
		return json.Marshal(m)
	}
	if u.Selected != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Selected)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["outcome"] = "selected"
		return json.Marshal(m)
	}
	return []byte{}, nil
}

func (u *RequestPermissionOutcome) Validate() error {
	var count int
	if u.Cancelled != nil {
		count++
	}
	if u.Selected != nil {
		count++
	}
	if count != 1 {
		return errors.New("RequestPermissionOutcome must have exactly one variant set")
	}
	return nil
}

// Request for user permission to execute a tool call.  Sent when the agent needs authorization before performing a sensitive operation.  See protocol docs: [Requesting Permission](https://agentclientprotocol.com/protocol/tool-calls#requesting-permission)
type RequestPermissionRequest struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Available permission options for the user to choose from.
	Options []PermissionOption `json:"options"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
	// Details about the tool call requiring permission.
	ToolCall ToolCallUpdate `json:"toolCall"`
}

func (v *RequestPermissionRequest) Validate() error {
	if v.Options == nil {
		return fmt.Errorf("options is required")
	}
	return nil
}

// Response to a permission request.
type RequestPermissionResponse struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The user's decision on the permission request.
	Outcome RequestPermissionOutcome `json:"outcome"`
}

func (v *RequestPermissionResponse) Validate() error {
	return nil
}

// A resource that the server is capable of reading, included in a prompt or tool call result.
type ResourceLink struct {
	// Extension point for implementations
	Meta        any          `json:"_meta,omitempty"`
	Annotations *Annotations `json:"annotations,omitempty"`
	Description *string      `json:"description,omitempty"`
	MimeType    *string      `json:"mimeType,omitempty"`
	Name        string       `json:"name"`
	Size        *int         `json:"size,omitempty"`
	Title       *string      `json:"title,omitempty"`
	Uri         string       `json:"uri"`
}

// The sender or recipient of messages and data in a conversation.
type Role string

const (
	RoleAssistant Role = "assistant"
	RoleUser      Role = "user"
)

// A unique identifier for a conversation session between a client and agent.  Sessions maintain their own context, conversation history, and state, allowing multiple independent interactions with the same agent.  # Example  ”' use agent_client_protocol::SessionId; use std::sync::Arc;  let session_id = SessionId(Arc::from("sess_abc123def456")); ”'  See protocol docs: [Session ID](https://agentclientprotocol.com/protocol/session-setup#session-id)
type SessionId string

// A mode the agent can operate in.  See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
type SessionMode struct {
	// Extension point for implementations
	Meta        any           `json:"_meta,omitempty"`
	Description *string       `json:"description,omitempty"`
	Id          SessionModeId `json:"id"`
	Name        string        `json:"name"`
}

// Unique identifier for a Session Mode.
type SessionModeId string

// The set of modes and the one currently active.
type SessionModeState struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The set of modes that the Agent can operate in
	AvailableModes []SessionMode `json:"availableModes"`
	// The current mode the Agent is in.
	CurrentModeId SessionModeId `json:"currentModeId"`
}

// **UNSTABLE**  This capability is not part of the spec yet, and may be removed or changed at any point.  The set of models and the one currently active.
type SessionModelState struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The set of models that the Agent can use
	AvailableModels []ModelInfo `json:"availableModels"`
	// The current model the Agent is in.
	CurrentModelId ModelId `json:"currentModelId"`
}

// Notification containing a session update from the agent.  Used to stream real-time progress and results during prompt processing.  See protocol docs: [Agent Reports Output](https://agentclientprotocol.com/protocol/prompt-turn#3-agent-reports-output)
type SessionNotification struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The ID of the session this update pertains to.
	SessionId SessionId `json:"sessionId"`
	// The actual update content.
	Update SessionUpdate `json:"update"`
}

func (v *SessionNotification) Validate() error {
	return nil
}

// Different types of updates that can be sent during session processing.  These updates provide real-time feedback about the agent's progress.  See protocol docs: [Agent Reports Output](https://agentclientprotocol.com/protocol/prompt-turn#3-agent-reports-output)
// A chunk of the user's message being streamed.
type SessionUpdateUserMessageChunk struct {
	Content       ContentBlock `json:"content"`
	SessionUpdate string       `json:"sessionUpdate"`
}

// A chunk of the agent's response being streamed.
type SessionUpdateAgentMessageChunk struct {
	Content       ContentBlock `json:"content"`
	SessionUpdate string       `json:"sessionUpdate"`
}

// A chunk of the agent's internal reasoning being streamed.
type SessionUpdateAgentThoughtChunk struct {
	Content       ContentBlock `json:"content"`
	SessionUpdate string       `json:"sessionUpdate"`
}

// Notification that a new tool call has been initiated.
type SessionUpdateToolCall struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Content produced by the tool call.
	Content []ToolCallContent `json:"content,omitempty"`
	// The category of tool being invoked. Helps clients choose appropriate icons and UI treatment.
	Kind ToolKind `json:"kind,omitempty"`
	// File locations affected by this tool call. Enables "follow-along" features in clients.
	Locations []ToolCallLocation `json:"locations,omitempty"`
	// Raw input parameters sent to the tool.
	RawInput any `json:"rawInput,omitempty"`
	// Raw output returned by the tool.
	RawOutput     any    `json:"rawOutput,omitempty"`
	SessionUpdate string `json:"sessionUpdate"`
	// Current execution status of the tool call.
	Status ToolCallStatus `json:"status,omitempty"`
	// Human-readable title describing what the tool is doing.
	Title string `json:"title"`
	// Unique identifier for this tool call within the session.
	ToolCallId ToolCallId `json:"toolCallId"`
}

// Update on the status or results of a tool call.
type SessionUpdateToolCallUpdate struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Replace the content collection.
	Content []ToolCallContent `json:"content,omitempty"`
	// Update the tool kind.
	Kind *ToolKind `json:"kind,omitempty"`
	// Replace the locations collection.
	Locations []ToolCallLocation `json:"locations,omitempty"`
	// Update the raw input.
	RawInput any `json:"rawInput,omitempty"`
	// Update the raw output.
	RawOutput     any    `json:"rawOutput,omitempty"`
	SessionUpdate string `json:"sessionUpdate"`
	// Update the execution status.
	Status *ToolCallStatus `json:"status,omitempty"`
	// Update the human-readable title.
	Title *string `json:"title,omitempty"`
	// The ID of the tool call being updated.
	ToolCallId ToolCallId `json:"toolCallId"`
}

// The agent's execution plan for complex tasks. See protocol docs: [Agent Plan](https://agentclientprotocol.com/protocol/agent-plan)
type SessionUpdatePlan struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The list of tasks to be accomplished.  When updating a plan, the agent must send a complete list of all entries with their current status. The client replaces the entire plan with each update.
	Entries       []PlanEntry `json:"entries"`
	SessionUpdate string      `json:"sessionUpdate"`
}

// Available commands are ready or have changed
type SessionUpdateAvailableCommandsUpdate struct {
	AvailableCommands []AvailableCommand `json:"availableCommands"`
	SessionUpdate     string             `json:"sessionUpdate"`
}

// The current mode of the session has changed  See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
type SessionUpdateCurrentModeUpdate struct {
	CurrentModeId SessionModeId `json:"currentModeId"`
	SessionUpdate string        `json:"sessionUpdate"`
}

type SessionUpdate struct {
	UserMessageChunk        *SessionUpdateUserMessageChunk        `json:"-"`
	AgentMessageChunk       *SessionUpdateAgentMessageChunk       `json:"-"`
	AgentThoughtChunk       *SessionUpdateAgentThoughtChunk       `json:"-"`
	ToolCall                *SessionUpdateToolCall                `json:"-"`
	ToolCallUpdate          *SessionUpdateToolCallUpdate          `json:"-"`
	Plan                    *SessionUpdatePlan                    `json:"-"`
	AvailableCommandsUpdate *SessionUpdateAvailableCommandsUpdate `json:"-"`
	CurrentModeUpdate       *SessionUpdateCurrentModeUpdate       `json:"-"`
}

func (u *SessionUpdate) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var disc string
		if v, ok := m["sessionUpdate"]; ok {
			json.Unmarshal(v, &disc)
		}
		switch disc {
		case "user_message_chunk":
			var v SessionUpdateUserMessageChunk
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.UserMessageChunk = &v
			return nil
		case "agent_message_chunk":
			var v SessionUpdateAgentMessageChunk
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.AgentMessageChunk = &v
			return nil
		case "agent_thought_chunk":
			var v SessionUpdateAgentThoughtChunk
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.AgentThoughtChunk = &v
			return nil
		case "tool_call":
			var v SessionUpdateToolCall
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.ToolCall = &v
			return nil
		case "tool_call_update":
			var v SessionUpdateToolCallUpdate
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.ToolCallUpdate = &v
			return nil
		case "plan":
			var v SessionUpdatePlan
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Plan = &v
			return nil
		case "available_commands_update":
			var v SessionUpdateAvailableCommandsUpdate
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.AvailableCommandsUpdate = &v
			return nil
		case "current_mode_update":
			var v SessionUpdateCurrentModeUpdate
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.CurrentModeUpdate = &v
			return nil
		}
	}
	{
		var v SessionUpdateUserMessageChunk
		var match bool = true
		if _, ok := m["sessionUpdate"]; !ok {
			match = false
		}
		if _, ok := m["content"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.UserMessageChunk = &v
			return nil
		}
	}
	{
		var v SessionUpdateAgentMessageChunk
		var match bool = true
		if _, ok := m["sessionUpdate"]; !ok {
			match = false
		}
		if _, ok := m["content"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.AgentMessageChunk = &v
			return nil
		}
	}
	{
		var v SessionUpdateAgentThoughtChunk
		var match bool = true
		if _, ok := m["sessionUpdate"]; !ok {
			match = false
		}
		if _, ok := m["content"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.AgentThoughtChunk = &v
			return nil
		}
	}
	{
		var v SessionUpdateToolCall
		var match bool = true
		if _, ok := m["sessionUpdate"]; !ok {
			match = false
		}
		if _, ok := m["toolCallId"]; !ok {
			match = false
		}
		if _, ok := m["title"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.ToolCall = &v
			return nil
		}
	}
	{
		var v SessionUpdateToolCallUpdate
		var match bool = true
		if _, ok := m["sessionUpdate"]; !ok {
			match = false
		}
		if _, ok := m["toolCallId"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.ToolCallUpdate = &v
			return nil
		}
	}
	{
		var v SessionUpdatePlan
		var match bool = true
		if _, ok := m["sessionUpdate"]; !ok {
			match = false
		}
		if _, ok := m["entries"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Plan = &v
			return nil
		}
	}
	{
		var v SessionUpdateAvailableCommandsUpdate
		var match bool = true
		if _, ok := m["sessionUpdate"]; !ok {
			match = false
		}
		if _, ok := m["availableCommands"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.AvailableCommandsUpdate = &v
			return nil
		}
	}
	{
		var v SessionUpdateCurrentModeUpdate
		var match bool = true
		if _, ok := m["sessionUpdate"]; !ok {
			match = false
		}
		if _, ok := m["currentModeId"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.CurrentModeUpdate = &v
			return nil
		}
	}
	{
		var v SessionUpdateUserMessageChunk
		if json.Unmarshal(b, &v) == nil {
			u.UserMessageChunk = &v
			return nil
		}
	}
	{
		var v SessionUpdateAgentMessageChunk
		if json.Unmarshal(b, &v) == nil {
			u.AgentMessageChunk = &v
			return nil
		}
	}
	{
		var v SessionUpdateAgentThoughtChunk
		if json.Unmarshal(b, &v) == nil {
			u.AgentThoughtChunk = &v
			return nil
		}
	}
	{
		var v SessionUpdateToolCall
		if json.Unmarshal(b, &v) == nil {
			u.ToolCall = &v
			return nil
		}
	}
	{
		var v SessionUpdateToolCallUpdate
		if json.Unmarshal(b, &v) == nil {
			u.ToolCallUpdate = &v
			return nil
		}
	}
	{
		var v SessionUpdatePlan
		if json.Unmarshal(b, &v) == nil {
			u.Plan = &v
			return nil
		}
	}
	{
		var v SessionUpdateAvailableCommandsUpdate
		if json.Unmarshal(b, &v) == nil {
			u.AvailableCommandsUpdate = &v
			return nil
		}
	}
	{
		var v SessionUpdateCurrentModeUpdate
		if json.Unmarshal(b, &v) == nil {
			u.CurrentModeUpdate = &v
			return nil
		}
	}
	return nil
}
func (u SessionUpdate) MarshalJSON() ([]byte, error) {
	if u.UserMessageChunk != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.UserMessageChunk)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "user_message_chunk"
		return json.Marshal(m)
	}
	if u.AgentMessageChunk != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.AgentMessageChunk)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "agent_message_chunk"
		return json.Marshal(m)
	}
	if u.AgentThoughtChunk != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.AgentThoughtChunk)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "agent_thought_chunk"
		return json.Marshal(m)
	}
	if u.ToolCall != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ToolCall)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "tool_call"
		return json.Marshal(m)
	}
	if u.ToolCallUpdate != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.ToolCallUpdate)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "tool_call_update"
		return json.Marshal(m)
	}
	if u.Plan != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Plan)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "plan"
		return json.Marshal(m)
	}
	if u.AvailableCommandsUpdate != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.AvailableCommandsUpdate)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "available_commands_update"
		return json.Marshal(m)
	}
	if u.CurrentModeUpdate != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.CurrentModeUpdate)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["sessionUpdate"] = "current_mode_update"
		return json.Marshal(m)
	}
	return []byte{}, nil
}

func (u *SessionUpdate) Validate() error {
	var count int
	if u.UserMessageChunk != nil {
		count++
	}
	if u.AgentMessageChunk != nil {
		count++
	}
	if u.AgentThoughtChunk != nil {
		count++
	}
	if u.ToolCall != nil {
		count++
	}
	if u.ToolCallUpdate != nil {
		count++
	}
	if u.Plan != nil {
		count++
	}
	if u.AvailableCommandsUpdate != nil {
		count++
	}
	if u.CurrentModeUpdate != nil {
		count++
	}
	if count != 1 {
		return errors.New("SessionUpdate must have exactly one variant set")
	}
	return nil
}

// Request parameters for setting a session mode.
type SetSessionModeRequest struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The ID of the mode to set.
	ModeId SessionModeId `json:"modeId"`
	// The ID of the session to set the mode for.
	SessionId SessionId `json:"sessionId"`
}

func (v *SetSessionModeRequest) Validate() error {
	return nil
}

// Response to 'session/set_mode' method.
type SetSessionModeResponse struct {
	Meta any `json:"meta,omitempty"`
}

func (v *SetSessionModeResponse) Validate() error {
	return nil
}

// **UNSTABLE**  This capability is not part of the spec yet, and may be removed or changed at any point.  Request parameters for setting a session model.
type SetSessionModelRequest struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The ID of the model to set.
	ModelId ModelId `json:"modelId"`
	// The ID of the session to set the model for.
	SessionId SessionId `json:"sessionId"`
}

func (v *SetSessionModelRequest) Validate() error {
	return nil
}

// **UNSTABLE**  This capability is not part of the spec yet, and may be removed or changed at any point.  Response to 'session/set_model' method.
type SetSessionModelResponse struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
}

func (v *SetSessionModelResponse) Validate() error {
	return nil
}

// Reasons why an agent stops processing a prompt turn.  See protocol docs: [Stop Reasons](https://agentclientprotocol.com/protocol/prompt-turn#stop-reasons)
type StopReason string

const (
	StopReasonEndTurn         StopReason = "end_turn"
	StopReasonMaxTokens       StopReason = "max_tokens"
	StopReasonMaxTurnRequests StopReason = "max_turn_requests"
	StopReasonRefusal         StopReason = "refusal"
	StopReasonCancelled       StopReason = "cancelled"
)

// Exit status of a terminal command.
type TerminalExitStatus struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The process exit code (may be null if terminated by signal).
	ExitCode *int `json:"exitCode,omitempty"`
	// The signal that terminated the process (may be null if exited normally).
	Signal *string `json:"signal,omitempty"`
}

// Request to get the current output and status of a terminal.
type TerminalOutputRequest struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
	// The ID of the terminal to get output from.
	TerminalId string `json:"terminalId"`
}

func (v *TerminalOutputRequest) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

// Response containing the terminal output and exit status.
type TerminalOutputResponse struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Exit status if the command has completed.
	ExitStatus *TerminalExitStatus `json:"exitStatus,omitempty"`
	// The terminal output captured so far.
	Output string `json:"output"`
	// Whether the output was truncated due to byte limits.
	Truncated bool `json:"truncated"`
}

func (v *TerminalOutputResponse) Validate() error {
	if v.Output == "" {
		return fmt.Errorf("output is required")
	}
	return nil
}

// Text provided to or from an LLM.
type TextContent struct {
	// Extension point for implementations
	Meta        any          `json:"_meta,omitempty"`
	Annotations *Annotations `json:"annotations,omitempty"`
	Text        string       `json:"text"`
}

// Text-based resource contents.
type TextResourceContents struct {
	// Extension point for implementations
	Meta     any     `json:"_meta,omitempty"`
	MimeType *string `json:"mimeType,omitempty"`
	Text     string  `json:"text"`
	Uri      string  `json:"uri"`
}

// Represents a tool call that the language model has requested.  Tool calls are actions that the agent executes on behalf of the language model, such as reading files, executing code, or fetching data from external sources.  See protocol docs: [Tool Calls](https://agentclientprotocol.com/protocol/tool-calls)
type ToolCall struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Content produced by the tool call.
	Content []ToolCallContent `json:"content,omitempty"`
	// The category of tool being invoked. Helps clients choose appropriate icons and UI treatment.
	Kind ToolKind `json:"kind,omitempty"`
	// File locations affected by this tool call. Enables "follow-along" features in clients.
	Locations []ToolCallLocation `json:"locations,omitempty"`
	// Raw input parameters sent to the tool.
	RawInput any `json:"rawInput,omitempty"`
	// Raw output returned by the tool.
	RawOutput any `json:"rawOutput,omitempty"`
	// Current execution status of the tool call.
	Status ToolCallStatus `json:"status,omitempty"`
	// Human-readable title describing what the tool is doing.
	Title string `json:"title"`
	// Unique identifier for this tool call within the session.
	ToolCallId ToolCallId `json:"toolCallId"`
}

// Content produced by a tool call.  Tool calls can produce different types of content including standard content blocks (text, images) or file diffs.  See protocol docs: [Content](https://agentclientprotocol.com/protocol/tool-calls#content)
// Standard content block (text, images, resources).
type ToolCallContentContent struct {
	// The actual content block.
	Content ContentBlock `json:"content"`
	Type    string       `json:"type"`
}

// File modification shown as a diff.
type ToolCallContentDiff struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The new content after modification.
	NewText string `json:"newText"`
	// The original content (None for new files).
	OldText *string `json:"oldText,omitempty"`
	// The file path being modified.
	Path string `json:"path"`
	Type string `json:"type"`
}

// Embed a terminal created with 'terminal/create' by its id.  The terminal must be added before calling 'terminal/release'.  See protocol docs: [Terminal](https://agentclientprotocol.com/protocol/terminal)
type ToolCallContentTerminal struct {
	TerminalId string `json:"terminalId"`
	Type       string `json:"type"`
}

type ToolCallContent struct {
	Content  *ToolCallContentContent  `json:"-"`
	Diff     *ToolCallContentDiff     `json:"-"`
	Terminal *ToolCallContentTerminal `json:"-"`
}

func (u *ToolCallContent) UnmarshalJSON(b []byte) error {
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return err
	}
	{
		var disc string
		if v, ok := m["type"]; ok {
			json.Unmarshal(v, &disc)
		}
		switch disc {
		case "content":
			var v ToolCallContentContent
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Content = &v
			return nil
		case "diff":
			var v ToolCallContentDiff
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Diff = &v
			return nil
		case "terminal":
			var v ToolCallContentTerminal
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Terminal = &v
			return nil
		}
	}
	{
		var v ToolCallContentContent
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["content"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Content = &v
			return nil
		}
	}
	{
		var v ToolCallContentDiff
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["path"]; !ok {
			match = false
		}
		if _, ok := m["newText"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Diff = &v
			return nil
		}
	}
	{
		var v ToolCallContentTerminal
		var match bool = true
		if _, ok := m["type"]; !ok {
			match = false
		}
		if _, ok := m["terminalId"]; !ok {
			match = false
		}
		if match {
			if json.Unmarshal(b, &v) != nil {
				return errors.New("invalid variant payload")
			}
			u.Terminal = &v
			return nil
		}
	}
	{
		var v ToolCallContentContent
		if json.Unmarshal(b, &v) == nil {
			u.Content = &v
			return nil
		}
	}
	{
		var v ToolCallContentDiff
		if json.Unmarshal(b, &v) == nil {
			u.Diff = &v
			return nil
		}
	}
	{
		var v ToolCallContentTerminal
		if json.Unmarshal(b, &v) == nil {
			u.Terminal = &v
			return nil
		}
	}
	return nil
}
func (u ToolCallContent) MarshalJSON() ([]byte, error) {
	if u.Content != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Content)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "content"
		return json.Marshal(m)
	}
	if u.Diff != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Diff)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "diff"
		return json.Marshal(m)
	}
	if u.Terminal != nil {
		var m map[string]any
		_b, _e := json.Marshal(*u.Terminal)
		if _e != nil {
			return []byte{}, _e
		}
		if json.Unmarshal(_b, &m) != nil {
			return []byte{}, errors.New("invalid variant payload")
		}
		m["type"] = "terminal"
		return json.Marshal(m)
	}
	return []byte{}, nil
}

func (u *ToolCallContent) Validate() error {
	var count int
	if u.Content != nil {
		count++
	}
	if u.Diff != nil {
		count++
	}
	if u.Terminal != nil {
		count++
	}
	if count != 1 {
		return errors.New("ToolCallContent must have exactly one variant set")
	}
	return nil
}

// Unique identifier for a tool call within a session.
type ToolCallId string

// A file location being accessed or modified by a tool.  Enables clients to implement "follow-along" features that track which files the agent is working with in real-time.  See protocol docs: [Following the Agent](https://agentclientprotocol.com/protocol/tool-calls#following-the-agent)
type ToolCallLocation struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Optional line number within the file.
	Line *int `json:"line,omitempty"`
	// The file path being accessed or modified.
	Path string `json:"path"`
}

// Execution status of a tool call.  Tool calls progress through different statuses during their lifecycle.  See protocol docs: [Status](https://agentclientprotocol.com/protocol/tool-calls#status)
type ToolCallStatus string

const (
	ToolCallStatusPending    ToolCallStatus = "pending"
	ToolCallStatusInProgress ToolCallStatus = "in_progress"
	ToolCallStatusCompleted  ToolCallStatus = "completed"
	ToolCallStatusFailed     ToolCallStatus = "failed"
)

// An update to an existing tool call.  Used to report progress and results as tools execute. All fields except the tool call ID are optional - only changed fields need to be included.  See protocol docs: [Updating](https://agentclientprotocol.com/protocol/tool-calls#updating)
type ToolCallUpdate struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// Replace the content collection.
	Content []ToolCallContent `json:"content,omitempty"`
	// Update the tool kind.
	Kind *ToolKind `json:"kind,omitempty"`
	// Replace the locations collection.
	Locations []ToolCallLocation `json:"locations,omitempty"`
	// Update the raw input.
	RawInput any `json:"rawInput,omitempty"`
	// Update the raw output.
	RawOutput any `json:"rawOutput,omitempty"`
	// Update the execution status.
	Status *ToolCallStatus `json:"status,omitempty"`
	// Update the human-readable title.
	Title *string `json:"title,omitempty"`
	// The ID of the tool call being updated.
	ToolCallId ToolCallId `json:"toolCallId"`
}

func (t *ToolCallUpdate) Validate() error {
	if t.ToolCallId == "" {
		return fmt.Errorf("toolCallId is required")
	}
	return nil
}

// Categories of tools that can be invoked.  Tool kinds help clients choose appropriate icons and optimize how they display tool execution progress.  See protocol docs: [Creating](https://agentclientprotocol.com/protocol/tool-calls#creating)
type ToolKind string

const (
	ToolKindRead       ToolKind = "read"
	ToolKindEdit       ToolKind = "edit"
	ToolKindDelete     ToolKind = "delete"
	ToolKindMove       ToolKind = "move"
	ToolKindSearch     ToolKind = "search"
	ToolKindExecute    ToolKind = "execute"
	ToolKindThink      ToolKind = "think"
	ToolKindFetch      ToolKind = "fetch"
	ToolKindSwitchMode ToolKind = "switch_mode"
	ToolKindOther      ToolKind = "other"
)

// Request to wait for a terminal command to exit.
type WaitForTerminalExitRequest struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
	// The ID of the terminal to wait for.
	TerminalId string `json:"terminalId"`
}

func (v *WaitForTerminalExitRequest) Validate() error {
	if v.TerminalId == "" {
		return fmt.Errorf("terminalId is required")
	}
	return nil
}

// Response containing the exit status of a terminal command.
type WaitForTerminalExitResponse struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The process exit code (may be null if terminated by signal).
	ExitCode *int `json:"exitCode,omitempty"`
	// The signal that terminated the process (may be null if exited normally).
	Signal *string `json:"signal,omitempty"`
}

func (v *WaitForTerminalExitResponse) Validate() error {
	return nil
}

// Request to write content to a text file.  Only available if the client supports the 'fs.writeTextFile' capability.
type WriteTextFileRequest struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
	// The text content to write to the file.
	Content string `json:"content"`
	// Absolute path to the file to write.
	Path string `json:"path"`
	// The session ID for this request.
	SessionId SessionId `json:"sessionId"`
}

func (v *WriteTextFileRequest) Validate() error {
	if v.Content == "" {
		return fmt.Errorf("content is required")
	}
	if v.Path == "" {
		return fmt.Errorf("path is required")
	}
	return nil
}

// Response to 'fs/write_text_file'
type WriteTextFileResponse struct {
	// Extension point for implementations
	Meta any `json:"_meta,omitempty"`
}

func (v *WriteTextFileResponse) Validate() error {
	return nil
}

type Agent interface {
	Authenticate(ctx context.Context, params AuthenticateRequest) (AuthenticateResponse, error)
	Initialize(ctx context.Context, params InitializeRequest) (InitializeResponse, error)
	Cancel(ctx context.Context, params CancelNotification) error
	NewSession(ctx context.Context, params NewSessionRequest) (NewSessionResponse, error)
	Prompt(ctx context.Context, params PromptRequest) (PromptResponse, error)
	SetSessionMode(ctx context.Context, params SetSessionModeRequest) (SetSessionModeResponse, error)
}

// AgentLoader defines optional support for loading sessions. Implement and advertise the capability to enable 'session/load'.
type AgentLoader interface {
	LoadSession(ctx context.Context, params LoadSessionRequest) (LoadSessionResponse, error)
}

// AgentExperimental defines unstable methods that are not part of the official spec. These may change or be removed without notice.
type AgentExperimental interface {
	SetSessionModel(ctx context.Context, params SetSessionModelRequest) (SetSessionModelResponse, error)
}
type Client interface {
	ReadTextFile(ctx context.Context, params ReadTextFileRequest) (ReadTextFileResponse, error)
	WriteTextFile(ctx context.Context, params WriteTextFileRequest) (WriteTextFileResponse, error)
	RequestPermission(ctx context.Context, params RequestPermissionRequest) (RequestPermissionResponse, error)
	SessionUpdate(ctx context.Context, params SessionNotification) error
	CreateTerminal(ctx context.Context, params CreateTerminalRequest) (CreateTerminalResponse, error)
	KillTerminalCommand(ctx context.Context, params KillTerminalCommandRequest) (KillTerminalCommandResponse, error)
	TerminalOutput(ctx context.Context, params TerminalOutputRequest) (TerminalOutputResponse, error)
	ReleaseTerminal(ctx context.Context, params ReleaseTerminalRequest) (ReleaseTerminalResponse, error)
	WaitForTerminalExit(ctx context.Context, params WaitForTerminalExitRequest) (WaitForTerminalExitResponse, error)
}

// ClientExperimental defines unstable methods that are not part of the official spec. These may change or be removed without notice.
type ClientExperimental interface{}
