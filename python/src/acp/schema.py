# generated by datamodel-codegen:
#   filename:  schema.json
#   timestamp: 2025-09-04T07:55:15+00:00

from __future__ import annotations

from enum import Enum
from typing import Annotated, Any, List, Literal, Optional, Union

from pydantic import BaseModel, Field, RootModel


class AuthenticateRequest(BaseModel):
    methodId: Annotated[
        str,
        Field(
            description='The ID of the authentication method to use.\nMust be one of the methods advertised in the initialize response.'
        ),
    ]


class AvailableCommandInput1(BaseModel):
    hint: Annotated[str, Field(description='A brief description of the expected input')]


class AvailableCommandInput(RootModel[AvailableCommandInput1]):
    root: AvailableCommandInput1


class BlobResourceContents(BaseModel):
    blob: str
    mimeType: Optional[str] = None
    uri: str


class CreateTerminalResponse(BaseModel):
    terminalId: str


class EnvVariable(BaseModel):
    name: Annotated[str, Field(description='The name of the environment variable.')]
    value: Annotated[
        str, Field(description='The value to set for the environment variable.')
    ]


class FileSystemCapability(BaseModel):
    readTextFile: Annotated[
        Optional[bool],
        Field(description='Whether the Client supports `fs/read_text_file` requests.'),
    ] = False
    writeTextFile: Annotated[
        Optional[bool],
        Field(description='Whether the Client supports `fs/write_text_file` requests.'),
    ] = False


class McpServer(BaseModel):
    args: Annotated[
        List[str],
        Field(description='Command-line arguments to pass to the MCP server.'),
    ]
    command: Annotated[str, Field(description='Path to the MCP server executable.')]
    env: Annotated[
        List[EnvVariable],
        Field(
            description='Environment variables to set when launching the MCP server.'
        ),
    ]
    name: Annotated[
        str, Field(description='Human-readable name identifying this MCP server.')
    ]


class NewSessionRequest(BaseModel):
    cwd: Annotated[
        str,
        Field(
            description='The working directory for this session. Must be an absolute path.'
        ),
    ]
    mcpServers: Annotated[
        List[McpServer],
        Field(
            description='List of MCP (Model Context Protocol) servers the agent should connect to.'
        ),
    ]


class PromptCapabilities(BaseModel):
    audio: Annotated[
        Optional[bool], Field(description='Agent supports [`ContentBlock::Audio`].')
    ] = False
    embeddedContext: Annotated[
        Optional[bool],
        Field(
            description='Agent supports embedded context in `session/prompt` requests.\n\nWhen enabled, the Client is allowed to include [`ContentBlock::Resource`]\nin prompt requests for pieces of context that are referenced in the message.'
        ),
    ] = False
    image: Annotated[
        Optional[bool], Field(description='Agent supports [`ContentBlock::Image`].')
    ] = False


class ReadTextFileResponse(BaseModel):
    content: str


class RequestPermissionOutcome1(BaseModel):
    outcome: Literal['cancelled']


class RequestPermissionOutcome2(BaseModel):
    optionId: Annotated[
        str, Field(description='The ID of the option the user selected.')
    ]
    outcome: Literal['selected']


class RequestPermissionResponse(BaseModel):
    outcome: Annotated[
        Union[RequestPermissionOutcome1, RequestPermissionOutcome2],
        Field(description="The user's decision on the permission request."),
    ]


class Role(Enum):
    assistant = 'assistant'
    user = 'user'


class TerminalExitStatus(BaseModel):
    exitCode: Annotated[Optional[int], Field(ge=0)] = None
    signal: Optional[str] = None


class TerminalOutputRequest(BaseModel):
    sessionId: Annotated[
        str,
        Field(
            description='A unique identifier for a conversation session between a client and agent.\n\nSessions maintain their own context, conversation history, and state,\nallowing multiple independent interactions with the same agent.\n\n# Example\n\n```\nuse agent_client_protocol::SessionId;\nuse std::sync::Arc;\n\nlet session_id = SessionId(Arc::from("sess_abc123def456"));\n```\n\nSee protocol docs: [Session ID](https://agentclientprotocol.com/protocol/session-setup#session-id)'
        ),
    ]
    terminalId: str


class TerminalOutputResponse(BaseModel):
    exitStatus: Optional[TerminalExitStatus] = None
    output: str
    truncated: bool


class TextResourceContents(BaseModel):
    mimeType: Optional[str] = None
    text: str
    uri: str


class ToolCallContent2(BaseModel):
    newText: Annotated[str, Field(description='The new content after modification.')]
    oldText: Annotated[
        Optional[str], Field(description='The original content (None for new files).')
    ] = None
    path: Annotated[str, Field(description='The file path being modified.')]
    type: Literal['diff']


class ToolCallContent3(BaseModel):
    terminalId: str
    type: Literal['terminal']


class ToolCallLocation(BaseModel):
    line: Annotated[
        Optional[int], Field(description='Optional line number within the file.', ge=0)
    ] = None
    path: Annotated[str, Field(description='The file path being accessed or modified.')]


class WaitForTerminalExitRequest(BaseModel):
    sessionId: Annotated[
        str,
        Field(
            description='A unique identifier for a conversation session between a client and agent.\n\nSessions maintain their own context, conversation history, and state,\nallowing multiple independent interactions with the same agent.\n\n# Example\n\n```\nuse agent_client_protocol::SessionId;\nuse std::sync::Arc;\n\nlet session_id = SessionId(Arc::from("sess_abc123def456"));\n```\n\nSee protocol docs: [Session ID](https://agentclientprotocol.com/protocol/session-setup#session-id)'
        ),
    ]
    terminalId: str


class WaitForTerminalExitResponse(BaseModel):
    exitCode: Annotated[Optional[int], Field(ge=0)] = None
    signal: Optional[str] = None


class WriteTextFileRequest(BaseModel):
    content: Annotated[str, Field(description='The text content to write to the file.')]
    path: Annotated[str, Field(description='Absolute path to the file to write.')]
    sessionId: Annotated[str, Field(description='The session ID for this request.')]


class AgentCapabilities(BaseModel):
    loadSession: Annotated[
        Optional[bool], Field(description='Whether the agent supports `session/load`.')
    ] = False
    promptCapabilities: Annotated[
        Optional[PromptCapabilities],
        Field(description='Prompt capabilities supported by the agent.'),
    ] = {'audio': False, 'embeddedContext': False, 'image': False}


class Annotations(BaseModel):
    audience: Optional[List[Role]] = None
    lastModified: Optional[str] = None
    priority: Optional[float] = None


class AudioContent(BaseModel):
    annotations: Optional[Annotations] = None
    data: str
    mimeType: str


class AuthMethod(BaseModel):
    description: Annotated[
        Optional[str],
        Field(
            description='Optional description providing more details about this authentication method.'
        ),
    ] = None
    id: Annotated[
        str, Field(description='Unique identifier for this authentication method.')
    ]
    name: Annotated[
        str, Field(description='Human-readable name of the authentication method.')
    ]


class AvailableCommand(BaseModel):
    description: Annotated[
        str, Field(description='Human-readable description of what the command does.')
    ]
    input: Annotated[
        Optional[AvailableCommandInput],
        Field(description='Input for the command if required'),
    ] = None
    name: Annotated[
        str,
        Field(description='Command name (e.g., "create_plan", "research_codebase").'),
    ]


class CancelNotification(BaseModel):
    sessionId: Annotated[
        str, Field(description='The ID of the session to cancel operations for.')
    ]


class ClientCapabilities(BaseModel):
    fs: Annotated[
        Optional[FileSystemCapability],
        Field(
            description='File system capabilities supported by the client.\nDetermines which file operations the agent can request.'
        ),
    ] = {'readTextFile': False, 'writeTextFile': False}
    terminal: Annotated[
        Optional[bool],
        Field(
            description='**UNSTABLE**\n\nThis capability is not part of the spec yet, and may be removed or changed at any point.'
        ),
    ] = False


class ClientNotification(RootModel[CancelNotification]):
    root: Annotated[
        CancelNotification,
        Field(
            description="All possible notifications that a client can send to an agent.\n\nThis enum is used internally for routing RPC notifications. You typically won't need\nto use this directly - use the notification methods on the [`Agent`] trait instead.\n\nNotifications do not expect a response."
        ),
    ]


class ContentBlock1(BaseModel):
    annotations: Optional[Annotations] = None
    text: str
    type: Literal['text']


class ContentBlock2(BaseModel):
    annotations: Optional[Annotations] = None
    data: str
    mimeType: str
    type: Literal['image']
    uri: Optional[str] = None


class ContentBlock3(BaseModel):
    annotations: Optional[Annotations] = None
    data: str
    mimeType: str
    type: Literal['audio']


class ContentBlock4(BaseModel):
    annotations: Optional[Annotations] = None
    description: Optional[str] = None
    mimeType: Optional[str] = None
    name: str
    size: Optional[int] = None
    title: Optional[str] = None
    type: Literal['resource_link']
    uri: str


class CreateTerminalRequest(BaseModel):
    args: Optional[List[str]] = None
    command: str
    cwd: Optional[str] = None
    env: Optional[List[EnvVariable]] = None
    outputByteLimit: Annotated[Optional[int], Field(ge=0)] = None
    sessionId: Annotated[
        str,
        Field(
            description='A unique identifier for a conversation session between a client and agent.\n\nSessions maintain their own context, conversation history, and state,\nallowing multiple independent interactions with the same agent.\n\n# Example\n\n```\nuse agent_client_protocol::SessionId;\nuse std::sync::Arc;\n\nlet session_id = SessionId(Arc::from("sess_abc123def456"));\n```\n\nSee protocol docs: [Session ID](https://agentclientprotocol.com/protocol/session-setup#session-id)'
        ),
    ]


class ImageContent(BaseModel):
    annotations: Optional[Annotations] = None
    data: str
    mimeType: str
    uri: Optional[str] = None


class InitializeRequest(BaseModel):
    clientCapabilities: Annotated[
        Optional[ClientCapabilities],
        Field(description='Capabilities supported by the client.'),
    ] = {'fs': {'readTextFile': False, 'writeTextFile': False}, 'terminal': False}
    protocolVersion: Annotated[
        int,
        Field(
            description='The latest protocol version supported by the client.',
            ge=0,
            le=65535,
        ),
    ]


class InitializeResponse(BaseModel):
    agentCapabilities: Annotated[
        Optional[AgentCapabilities],
        Field(description='Capabilities supported by the agent.'),
    ] = {
        'loadSession': False,
        'promptCapabilities': {
            'audio': False,
            'embeddedContext': False,
            'image': False,
        },
    }
    authMethods: Annotated[
        Optional[List[AuthMethod]],
        Field(description='Authentication methods supported by the agent.'),
    ] = []
    protocolVersion: Annotated[
        int,
        Field(
            description="The protocol version the client specified if supported by the agent,\nor the latest protocol version supported by the agent.\n\nThe client should disconnect, if it doesn't support this version.",
            ge=0,
            le=65535,
        ),
    ]


class KillTerminalRequest(BaseModel):
    sessionId: Annotated[
        str,
        Field(
            description='A unique identifier for a conversation session between a client and agent.\n\nSessions maintain their own context, conversation history, and state,\nallowing multiple independent interactions with the same agent.\n\n# Example\n\n```\nuse agent_client_protocol::SessionId;\nuse std::sync::Arc;\n\nlet session_id = SessionId(Arc::from("sess_abc123def456"));\n```\n\nSee protocol docs: [Session ID](https://agentclientprotocol.com/protocol/session-setup#session-id)'
        ),
    ]
    terminalId: str


class LoadSessionRequest(BaseModel):
    cwd: Annotated[str, Field(description='The working directory for this session.')]
    mcpServers: Annotated[
        List[McpServer],
        Field(description='List of MCP servers to connect to for this session.'),
    ]
    sessionId: Annotated[str, Field(description='The ID of the session to load.')]


class NewSessionResponse(BaseModel):
    sessionId: Annotated[
        str,
        Field(
            description='Unique identifier for the created session.\n\nUsed in all subsequent requests for this conversation.'
        ),
    ]


class PermissionOption(BaseModel):
    kind: Annotated[
        str, Field(description='Hint about the nature of this permission option.')
    ]
    name: Annotated[
        str, Field(description='Human-readable label to display to the user.')
    ]
    optionId: Annotated[
        str, Field(description='Unique identifier for this permission option.')
    ]


class PlanEntry(BaseModel):
    content: Annotated[
        str,
        Field(
            description='Human-readable description of what this task aims to accomplish.'
        ),
    ]
    priority: Annotated[
        str,
        Field(
            description='The relative importance of this task.\nUsed to indicate which tasks are most critical to the overall goal.'
        ),
    ]
    status: Annotated[str, Field(description='Current execution status of this task.')]


class PromptResponse(BaseModel):
    stopReason: Annotated[
        str, Field(description='Indicates why the agent stopped processing the turn.')
    ]


class ReadTextFileRequest(BaseModel):
    limit: Annotated[
        Optional[int],
        Field(description='Optional maximum number of lines to read.', ge=0),
    ] = None
    line: Annotated[
        Optional[int],
        Field(
            description='Optional line number to start reading from (1-based).', ge=0
        ),
    ] = None
    path: Annotated[str, Field(description='Absolute path to the file to read.')]
    sessionId: Annotated[str, Field(description='The session ID for this request.')]


class ReleaseTerminalRequest(BaseModel):
    sessionId: Annotated[
        str,
        Field(
            description='A unique identifier for a conversation session between a client and agent.\n\nSessions maintain their own context, conversation history, and state,\nallowing multiple independent interactions with the same agent.\n\n# Example\n\n```\nuse agent_client_protocol::SessionId;\nuse std::sync::Arc;\n\nlet session_id = SessionId(Arc::from("sess_abc123def456"));\n```\n\nSee protocol docs: [Session ID](https://agentclientprotocol.com/protocol/session-setup#session-id)'
        ),
    ]
    terminalId: str


class ResourceLink(BaseModel):
    annotations: Optional[Annotations] = None
    description: Optional[str] = None
    mimeType: Optional[str] = None
    name: str
    size: Optional[int] = None
    title: Optional[str] = None
    uri: str


class SessionUpdate6(BaseModel):
    entries: Annotated[
        List[PlanEntry],
        Field(
            description='The list of tasks to be accomplished.\n\nWhen updating a plan, the agent must send a complete list of all entries\nwith their current status. The client replaces the entire plan with each update.'
        ),
    ]
    sessionUpdate: Literal['plan']


class SessionUpdate7(BaseModel):
    availableCommands: List[AvailableCommand]
    sessionUpdate: Literal['available_commands_update']


class TextContent(BaseModel):
    annotations: Optional[Annotations] = None
    text: str


class ContentBlock5(BaseModel):
    annotations: Optional[Annotations] = None
    resource: Annotated[
        Union[TextResourceContents, BlobResourceContents],
        Field(description='Resource content that can be embedded in a message.'),
    ]
    type: Literal['resource']


class EmbeddedResource(BaseModel):
    annotations: Optional[Annotations] = None
    resource: Annotated[
        Union[TextResourceContents, BlobResourceContents],
        Field(description='Resource content that can be embedded in a message.'),
    ]


class Plan(BaseModel):
    entries: Annotated[
        List[PlanEntry],
        Field(
            description='The list of tasks to be accomplished.\n\nWhen updating a plan, the agent must send a complete list of all entries\nwith their current status. The client replaces the entire plan with each update.'
        ),
    ]


class PromptRequest(BaseModel):
    prompt: Annotated[
        List[
            Union[
                ContentBlock1,
                ContentBlock2,
                ContentBlock3,
                ContentBlock4,
                ContentBlock5,
            ]
        ],
        Field(
            description="The blocks of content that compose the user's message.\n\nAs a baseline, the Agent MUST support [`ContentBlock::Text`] and [`ContentBlock::ResourceLink`],\nwhile other variants are optionally enabled via [`PromptCapabilities`].\n\nThe Client MUST adapt its interface according to [`PromptCapabilities`].\n\nThe client MAY include referenced pieces of context as either\n[`ContentBlock::Resource`] or [`ContentBlock::ResourceLink`].\n\nWhen available, [`ContentBlock::Resource`] is preferred\nas it avoids extra round-trips and allows the message to include\npieces of context from sources the agent may not have access to."
        ),
    ]
    sessionId: Annotated[
        str, Field(description='The ID of the session to send this user message to')
    ]


class SessionUpdate1(BaseModel):
    content: Annotated[
        Union[
            ContentBlock1, ContentBlock2, ContentBlock3, ContentBlock4, ContentBlock5
        ],
        Field(
            description="Content blocks represent displayable information in the Agent Client Protocol.\n\nThey provide a structured way to handle various types of user-facing content—whether\nit's text from language models, images for analysis, or embedded resources for context.\n\nContent blocks appear in:\n- User prompts sent via `session/prompt`\n- Language model output streamed through `session/update` notifications\n- Progress updates and results from tool calls\n\nThis structure is compatible with the Model Context Protocol (MCP), enabling\nagents to seamlessly forward content from MCP tool outputs without transformation.\n\nSee protocol docs: [Content](https://agentclientprotocol.com/protocol/content)"
        ),
    ]
    sessionUpdate: Literal['user_message_chunk']


class SessionUpdate2(BaseModel):
    content: Annotated[
        Union[
            ContentBlock1, ContentBlock2, ContentBlock3, ContentBlock4, ContentBlock5
        ],
        Field(
            description="Content blocks represent displayable information in the Agent Client Protocol.\n\nThey provide a structured way to handle various types of user-facing content—whether\nit's text from language models, images for analysis, or embedded resources for context.\n\nContent blocks appear in:\n- User prompts sent via `session/prompt`\n- Language model output streamed through `session/update` notifications\n- Progress updates and results from tool calls\n\nThis structure is compatible with the Model Context Protocol (MCP), enabling\nagents to seamlessly forward content from MCP tool outputs without transformation.\n\nSee protocol docs: [Content](https://agentclientprotocol.com/protocol/content)"
        ),
    ]
    sessionUpdate: Literal['agent_message_chunk']


class SessionUpdate3(BaseModel):
    content: Annotated[
        Union[
            ContentBlock1, ContentBlock2, ContentBlock3, ContentBlock4, ContentBlock5
        ],
        Field(
            description="Content blocks represent displayable information in the Agent Client Protocol.\n\nThey provide a structured way to handle various types of user-facing content—whether\nit's text from language models, images for analysis, or embedded resources for context.\n\nContent blocks appear in:\n- User prompts sent via `session/prompt`\n- Language model output streamed through `session/update` notifications\n- Progress updates and results from tool calls\n\nThis structure is compatible with the Model Context Protocol (MCP), enabling\nagents to seamlessly forward content from MCP tool outputs without transformation.\n\nSee protocol docs: [Content](https://agentclientprotocol.com/protocol/content)"
        ),
    ]
    sessionUpdate: Literal['agent_thought_chunk']


class ToolCallContent1(BaseModel):
    content: Annotated[
        Union[
            ContentBlock1, ContentBlock2, ContentBlock3, ContentBlock4, ContentBlock5
        ],
        Field(description='The actual content block.'),
    ]
    type: Literal['content']


class ToolCallUpdate(BaseModel):
    content: Annotated[
        Optional[List[Union[ToolCallContent1, ToolCallContent2, ToolCallContent3]]],
        Field(description='Replace the content collection.'),
    ] = None
    kind: Annotated[Optional[str], Field(description='Update the tool kind.')] = None
    locations: Annotated[
        Optional[List[ToolCallLocation]],
        Field(description='Replace the locations collection.'),
    ] = None
    rawInput: Annotated[Optional[Any], Field(description='Update the raw input.')] = (
        None
    )
    rawOutput: Annotated[Optional[Any], Field(description='Update the raw output.')] = (
        None
    )
    status: Annotated[
        Optional[str], Field(description='Update the execution status.')
    ] = None
    title: Annotated[
        Optional[str], Field(description='Update the human-readable title.')
    ] = None
    toolCallId: Annotated[
        str, Field(description='The ID of the tool call being updated.')
    ]


class RequestPermissionRequest(BaseModel):
    options: Annotated[
        List[PermissionOption],
        Field(description='Available permission options for the user to choose from.'),
    ]
    sessionId: Annotated[str, Field(description='The session ID for this request.')]
    toolCall: Annotated[
        ToolCallUpdate,
        Field(description='Details about the tool call requiring permission.'),
    ]


class SessionUpdate4(BaseModel):
    content: Annotated[
        Optional[List[Union[ToolCallContent1, ToolCallContent2, ToolCallContent3]]],
        Field(description='Content produced by the tool call.'),
    ] = None
    kind: Annotated[
        Optional[str],
        Field(
            description='The category of tool being invoked.\nHelps clients choose appropriate icons and UI treatment.'
        ),
    ] = None
    locations: Annotated[
        Optional[List[ToolCallLocation]],
        Field(
            description='File locations affected by this tool call.\nEnables "follow-along" features in clients.'
        ),
    ] = None
    rawInput: Annotated[
        Optional[Any], Field(description='Raw input parameters sent to the tool.')
    ] = None
    rawOutput: Annotated[
        Optional[Any], Field(description='Raw output returned by the tool.')
    ] = None
    sessionUpdate: Literal['tool_call']
    status: Annotated[
        Optional[str], Field(description='Current execution status of the tool call.')
    ] = None
    title: Annotated[
        str,
        Field(description='Human-readable title describing what the tool is doing.'),
    ]
    toolCallId: Annotated[
        str,
        Field(description='Unique identifier for this tool call within the session.'),
    ]


class SessionUpdate5(BaseModel):
    content: Annotated[
        Optional[List[Union[ToolCallContent1, ToolCallContent2, ToolCallContent3]]],
        Field(description='Replace the content collection.'),
    ] = None
    kind: Annotated[Optional[str], Field(description='Update the tool kind.')] = None
    locations: Annotated[
        Optional[List[ToolCallLocation]],
        Field(description='Replace the locations collection.'),
    ] = None
    rawInput: Annotated[Optional[Any], Field(description='Update the raw input.')] = (
        None
    )
    rawOutput: Annotated[Optional[Any], Field(description='Update the raw output.')] = (
        None
    )
    sessionUpdate: Literal['tool_call_update']
    status: Annotated[
        Optional[str], Field(description='Update the execution status.')
    ] = None
    title: Annotated[
        Optional[str], Field(description='Update the human-readable title.')
    ] = None
    toolCallId: Annotated[
        str, Field(description='The ID of the tool call being updated.')
    ]


class ToolCall(BaseModel):
    content: Annotated[
        Optional[List[Union[ToolCallContent1, ToolCallContent2, ToolCallContent3]]],
        Field(description='Content produced by the tool call.'),
    ] = None
    kind: Annotated[
        Optional[str],
        Field(
            description='The category of tool being invoked.\nHelps clients choose appropriate icons and UI treatment.'
        ),
    ] = None
    locations: Annotated[
        Optional[List[ToolCallLocation]],
        Field(
            description='File locations affected by this tool call.\nEnables "follow-along" features in clients.'
        ),
    ] = None
    rawInput: Annotated[
        Optional[Any], Field(description='Raw input parameters sent to the tool.')
    ] = None
    rawOutput: Annotated[
        Optional[Any], Field(description='Raw output returned by the tool.')
    ] = None
    status: Annotated[
        Optional[str], Field(description='Current execution status of the tool call.')
    ] = None
    title: Annotated[
        str,
        Field(description='Human-readable title describing what the tool is doing.'),
    ]
    toolCallId: Annotated[
        str,
        Field(description='Unique identifier for this tool call within the session.'),
    ]


class SessionNotification(BaseModel):
    sessionId: Annotated[
        str, Field(description='The ID of the session this update pertains to.')
    ]
    update: Annotated[
        Union[
            SessionUpdate1,
            SessionUpdate2,
            SessionUpdate3,
            SessionUpdate4,
            SessionUpdate5,
            SessionUpdate6,
            SessionUpdate7,
        ],
        Field(description='The actual update content.'),
    ]


class AgentNotification(RootModel[SessionNotification]):
    root: Annotated[
        SessionNotification,
        Field(
            description="All possible notifications that an agent can send to a client.\n\nThis enum is used internally for routing RPC notifications. You typically won't need\nto use this directly - use the notification methods on the [`Client`] trait instead.\n\nNotifications do not expect a response."
        ),
    ]


class Model(
    RootModel[
        Union[
            ClientNotification,
            AgentNotification,
            Union[
                WriteTextFileRequest,
                ReadTextFileRequest,
                RequestPermissionRequest,
                CreateTerminalRequest,
                TerminalOutputRequest,
                ReleaseTerminalRequest,
                WaitForTerminalExitRequest,
                KillTerminalRequest,
            ],
            Optional[
                Union[
                    ReadTextFileResponse,
                    RequestPermissionResponse,
                    CreateTerminalResponse,
                    TerminalOutputResponse,
                    WaitForTerminalExitResponse,
                ]
            ],
            Union[
                InitializeRequest,
                AuthenticateRequest,
                NewSessionRequest,
                LoadSessionRequest,
                PromptRequest,
            ],
            Optional[Union[InitializeResponse, NewSessionResponse, PromptResponse]],
        ]
    ]
):
    root: Union[
        ClientNotification,
        AgentNotification,
        Union[
            WriteTextFileRequest,
            ReadTextFileRequest,
            RequestPermissionRequest,
            CreateTerminalRequest,
            TerminalOutputRequest,
            ReleaseTerminalRequest,
            WaitForTerminalExitRequest,
            KillTerminalRequest,
        ],
        Optional[
            Union[
                ReadTextFileResponse,
                RequestPermissionResponse,
                CreateTerminalResponse,
                TerminalOutputResponse,
                WaitForTerminalExitResponse,
            ]
        ],
        Union[
            InitializeRequest,
            AuthenticateRequest,
            NewSessionRequest,
            LoadSessionRequest,
            PromptRequest,
        ],
        Optional[Union[InitializeResponse, NewSessionResponse, PromptResponse]],
    ]
